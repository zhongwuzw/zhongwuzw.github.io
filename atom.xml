<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>钟武的技术博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhongwuzw.github.io/"/>
  <updated>2020-09-24T02:55:42.977Z</updated>
  <id>https://zhongwuzw.github.io/</id>
  
  <author>
    <name>钟武</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter InheritedWidget实现原理</title>
    <link href="https://zhongwuzw.github.io/2020/09/24/Flutter-InheritedWidget%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    <id>https://zhongwuzw.github.io/2020/09/24/Flutter-InheritedWidget实现原理/</id>
    <published>2020-09-24T02:50:54.000Z</published>
    <updated>2020-09-24T02:55:42.977Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在Flutter开发中，对于一些简单的数据传递，我们可以使用Widget constructor直接传递进去，但是当某个后代Widget依赖上层的祖先Widget或者多个Widget同时依赖祖先Widget的情形时，直接传递的方式就会暴露出很多的问题：需要连续传递很难维护以及依赖的祖先Widget数据改变时，所有子Widget都需要rebuild。</p>
<p>Flutter提供了另外一个机制来解决这个问题，InheritedWidget，当InheritedWidget数据发生变化时，只通知依赖其数据变化的Widgets，接下来将按步骤分析实现细节。（ <a href="https://github.com/rrousselGit/provider?spm=ata.13261165.0.0.36547ede70zxv7" target="_blank" rel="external">Provider</a>也是基于InheritedWidget进行的封装）</p>
<p><img src="/images/flutter_inheritedWidget.png" alt=""></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><hr>
<p>我们通过一个小demo来展示使用方法，假设数据Color需要被后代Widget访问，且当Color变化，后代Widget能监听到变化。步骤比较简单，先子类InheritedWidget，如下代码示例，FrogColor定义了一个名为of的静态方法，该方法由后代Widget进行调用，调用时将后代Widget的Element作为context传入。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrogColor</span> <span class="keyword">extends</span> <span class="title">InheritedWidget</span> </span>&#123;</div><div class="line">  const <span class="type">FrogColor</span>(&#123;</div><div class="line">    <span class="type">Key</span> key,</div><div class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.color,</div><div class="line">    <span class="meta">@required</span> <span class="type">Widget</span> child,</div><div class="line">  &#125;) : assert(color != <span class="literal">null</span>),</div><div class="line">       assert(child != <span class="literal">null</span>),</div><div class="line">       <span class="keyword">super</span>(key: key, child: child);</div><div class="line"></div><div class="line">  <span class="keyword">final</span> <span class="type">Color</span> color;</div><div class="line"></div><div class="line">  static <span class="type">FrogColor</span> of(<span class="type">BuildContext</span> context) &#123;</div><div class="line">    <span class="keyword">return</span> context.dependOnInheritedWidgetOfExactType&lt;<span class="type">FrogColor</span>&gt;();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@override</span></div><div class="line">  bool updateShouldNotify(<span class="type">FrogColor</span> old) =&gt; color != old.color;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看下of静态方法的实现，实际调用的是后代Widget对应Element的 dependOnInheritedWidgetOfExactType，该方法首先会去_inheritedWidgets里找是否有需要的InheritedWidget，如果找到，返回找到的InheritedWidget，并将自己作为依赖注册到InheritedWidget里，这样InheritedWidget就能知道哪些Widget依赖它，如果InheritedWidget发生了变化，会通知依赖方。_inheritedWidgets会在InheritedWidget mount的时候从父Element获取当前所有的InheritedWidgets，并且把自己也加到里边，也就是说，所有的Element都有一个Map来收集当前祖先所有的InheritedWidget。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line">T dependOnInheritedWidgetOfExactType&lt;T <span class="keyword">extends</span> InheritedWidget&gt;(&#123;<span class="built_in">Object</span> aspect&#125;) &#123;</div><div class="line">  <span class="keyword">assert</span>(_debugCheckStateIsActiveForAncestorLookup());</div><div class="line">  <span class="keyword">final</span> InheritedElement ancestor = _inheritedWidgets == <span class="keyword">null</span> ? <span class="keyword">null</span> : _inheritedWidgets[T];</div><div class="line">  <span class="keyword">if</span> (ancestor != <span class="keyword">null</span>) &#123;</div><div class="line">    <span class="keyword">assert</span>(ancestor <span class="keyword">is</span> InheritedElement);</div><div class="line">    <span class="keyword">return</span> dependOnInheritedElement(ancestor, aspect: aspect) <span class="keyword">as</span> T;</div><div class="line">  &#125;</div><div class="line">  _hadUnsatisfiedDependencies = <span class="keyword">true</span>;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>重新回到FrogColor类，另一个方法updateShouldNotify，当FrogColor widget rebuild时，FrogColor的Element会通过updated方法来判断是否需要通知所有依赖它的后代Widgets，super.updated(oldWidget)用来通知所有的dependencies 依赖方。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@override</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">updated</span><span class="params">(InheritedWidget oldWidget)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (widget.updateShouldNotify(oldWidget))</div><div class="line">    <span class="keyword">super</span>.updated(oldWidget);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当需要通知依赖方的时候，调用依赖Widget对应Element的didChangeDependencies方法，Element将自己标记为dirty，并加到BuildOwner的dirty列表中，当下一帧绘制时，会重新build Widget。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@mustCallSuper</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">didChangeDependencies</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="keyword">assert</span>(_active); <span class="comment">// otherwise markNeedsBuild is a no-op</span></div><div class="line">  <span class="keyword">assert</span>(_debugCheckOwnerBuildTargetExists(<span class="string">'didChangeDependencies'</span>));</div><div class="line">  markNeedsBuild();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>综上，我们可以看到，InheritedWidget不仅能解决多层传递带来的业务复杂度，也能非常高效的进行rebuild操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在Flutter开发中，对于一些简单的数据传递，我们可以使用Widget constructor直接传递进去，但是当某个后代Wid
    
    </summary>
    
      <category term="Flutter" scheme="https://zhongwuzw.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://zhongwuzw.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>Flutter Dart垃圾回收</title>
    <link href="https://zhongwuzw.github.io/2020/09/24/Flutter-Dart%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://zhongwuzw.github.io/2020/09/24/Flutter-Dart垃圾回收/</id>
    <published>2020-09-24T02:15:48.000Z</published>
    <updated>2020-09-24T02:50:38.097Z</updated>
    
    <content type="html"><![CDATA[<hr>
<p>Flutter使用Dart作为开发语言以及运行时，Dart 运行时存在于Debug和Release模式，不过两个模式中的运行时有很大的区别。</p>
<p>Debug模式下，Dart运行时，JIT编译器/解释器（Android是JIT，iOS是解释器），Debug和Profile工具都会加载到设备上。而Release模式下，JIT编译器/解释器和Debug服务被移除，只包括运行时。</p>
<p><img src="/images/flutter_debug_release.png" alt=""></p>
<p> Dart运行时包含垃圾回收器，在对象创建和销毁时分配和释放内存。Flutter在运行中，会创建大量的对象，比如，伴随着在界面展示，不可见，app 状态变化等，会创建很多Staleless Widgets，其中很多生命周期都很短。一个比较复杂的UI界面，widgets数量能上千。</p>
<p> 那么Flutter 开发者是否需要关心垃圾回收？Flutter在高频次创建和销毁对象的情况下，开发者是否需要采取措施来限制这种行为？很多人会对不会变的widgets创建引用，保存在state中，来避免重建和销毁。其实这些是没有必要的，因为Dart垃圾回收器基于分代架构，且针对对象的快速创建和销毁做了优化，大多数情况下，让引擎自己管理所有widgets创建和销毁即可。</p>
<h2 id="Dart垃圾回收器"><a href="#Dart垃圾回收器" class="headerlink" title="Dart垃圾回收器"></a>Dart垃圾回收器</h2><hr>
<p>Dart的垃圾回收器由两部分组成：新生代scavenger和并发标记清除回收器。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>为了降低垃圾回收对UI性能的影响，垃圾回收器提供了hooks给flutter engine，当没有用户交互或app处于闲时状态时，flutter engine会通知垃圾回收器来进行收集，而不会影响想能。</p>
<p>当处于闲时状态时，垃圾回收器也能进行内存碎片整理，减少内存碎片。</p>
<h3 id="年轻代Scavenger"><a href="#年轻代Scavenger" class="headerlink" title="年轻代Scavenger"></a>年轻代Scavenger</h3><p>该阶段主要用来清理生命周期短的临时对象，如stateless widgets，会比次代标记/清除阶段更快，极大减小app运行过程中可能带来的卡顿。</p>
<p>对象创建时会在一片连续的内存空间进行分配，每次创建对象，都会再这片空间区域查找是否有可用的空间，当可用空间被占满，Dart会使用bump pointer（指针碰撞）的方式来快速分配新的空间。</p>
<p>新的空间分为两部分，称为半空间，任何时候，只有一半是处于激活的，另一半则处于非激活状态。新创建的对象会在激活的那部分空间进行分配，当激活部分被占满，引用不可释放的对象会从激活空间移到非激活空间，非激活空间将变为激活空间，以此反复。</p>
<p>为了确定当前的对象是否可释放，收集器会从根对象，如栈变量，来检测是否是否还有引用，引用的对象会被移动到非激活空间，最后，剩下的对象就是可释放对象，在后续的垃圾回收时，引用对象会直接覆盖之前的可释放对象占用的空间。更多细节，参看<a href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm?spm=ata.13261165.0.0.1f0058e56w9Oaq" target="_blank" rel="external">Cheney’s 算法</a>。</p>
<p><img src="/images/flutter_scavenger.png" alt=""></p>
<h3 id="并行标记和并发清除"><a href="#并行标记和并发清除" class="headerlink" title="并行标记和并发清除"></a>并行标记和并发清除</h3><p>当对象到达一定的生命周期，他们会被移入新的内存空间（老年代），由次代收集器（标记/清除）进行内存管理，收集器同样分两部分：首先会遍历对象图，标记还在使用的对象。遍历完成后，未被标记的对象会被回收。</p>
<p>注意，这种形式的垃圾回收会在标记阶段阻塞UI线程，且不能进行内存修改操作。不过，这个阶段发生的频率很低，因为生命周期短的对象都被年轻代scavenger处理了。</p>
<p>当然，如果开发的app不满足弱分代假说（即大多数对象会在年轻时死亡，生命周期短）的情况，那么该形式的垃圾回收会更容易发生。</p>
<h3 id="Heap-Map"><a href="#Heap-Map" class="headerlink" title="Heap Map"></a>Heap Map</h3><p>Observatory下可以通过heap map来观察某一时刻特定Isolate老年代的内存分配，如下图，不同的颜色代表不同的内存块，白色代表空闲空间，如果我们看到很多小的白色块，说明产生了内存碎片，可能考虑有内存泄漏了。</p>
<p><img src="/images/flutter_heap_map.png" alt=""></p>
<h2 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h2><hr>
<p>Dart的每个Isolate有自己的堆空间，每个Isolate也都运行在单独的线程中，垃圾回收时，互不影响性能，所以Isolate可以避免阻塞UI，进行CPU密集型、IO、网络等操作。</p>
<p><img src="/images/fkutter_isolates.png" alt=""></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a href="https://mrale.ph/dartvm/" target="_blank" rel="external">https://mrale.ph/dartvm/</a></li>
<li><a href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30" target="_blank" rel="external">https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30</a></li>
<li><a href="https://dart-lang.github.io/observatory/heap-map.html" target="_blank" rel="external">https://dart-lang.github.io/observatory/heap-map.html</a></li>
<li><a href="https://dart-lang.github.io/observatory/glossary.html?spm=ata.13261165.0.0.1f0058e56w9Oaq#memory-leak" target="_blank" rel="external">https://dart-lang.github.io/observatory/glossary.html?spm=ata.13261165.0.0.1f0058e56w9Oaq#memory-leak</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;Flutter使用Dart作为开发语言以及运行时，Dart 运行时存在于Debug和Release模式，不过两个模式中的运行时有很大的区别。&lt;/p&gt;
&lt;p&gt;Debug模式下，Dart运行时，JIT编译器/解释器（Android是JIT，iOS是解释器），Debug
    
    </summary>
    
      <category term="Flutter" scheme="https://zhongwuzw.github.io/categories/Flutter/"/>
    
    
      <category term="Flutter" scheme="https://zhongwuzw.github.io/tags/Flutter/"/>
    
      <category term="Dart" scheme="https://zhongwuzw.github.io/tags/Dart/"/>
    
  </entry>
  
  <entry>
    <title>iOS之获取Block retain的objects</title>
    <link href="https://zhongwuzw.github.io/2018/09/11/iOS%E4%B9%8B%E8%8E%B7%E5%8F%96Block-retain%E7%9A%84objects/"/>
    <id>https://zhongwuzw.github.io/2018/09/11/iOS之获取Block-retain的objects/</id>
    <published>2018-09-11T09:33:31.000Z</published>
    <updated>2018-09-11T10:25:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Block管理Objective-C对象实例的原理"><a href="#Block管理Objective-C对象实例的原理" class="headerlink" title="Block管理Objective-C对象实例的原理"></a>Block管理<code>Objective-C</code>对象实例的原理</h2><hr>
<p><code>Block</code>的实现结构体见如下图所示，<code>Block</code>对于捕获的<code>Objective-C</code>对象实例，会在<code>Block</code>实现的结构体中创建一个变量指向<code>Objective-C</code>对象实例，当<code>Block</code>将要释放时，会调用<code>dispose_helper</code>函数，该函数会调用所有需要进行内存管理的所捕获的对象，如<code>Block</code>、<code>__block</code>变量、<code>__attribute__((NSObject))</code>变量或有<code>constructor/destructor</code>的<code>C++</code> <code>const</code>对象。</p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/Block.png" alt=""></p>
<h2 id="获取Block-retain的Objective-C对象实例"><a href="#获取Block-retain的Objective-C对象实例" class="headerlink" title="获取Block retain的Objective-C对象实例"></a>获取Block retain的Objective-C对象实例</h2><hr>
<p>所以，怎么能够拿到<code>retain</code>的<code>Objective-C</code>对象实例呢，方法为创建<code>fake</code>对象，来模拟捕获的<code>Objective-C</code>对象实例，然后我们程序来调用<code>Block</code>的<code>dispose_helper</code>方法（<code>dispose_helper</code>方法接收一个参数，值为<code>Block</code>的指针），该方法会调用对象实例的<code>release</code>方法，我们只需要在<code>fake</code>对象中实现<code>release</code>方法，如果<code>release</code>方法被调用，所以该<code>fake</code>对象对应的真实变量为<code>Objective-C</code>对象实例。</p>
<p>那么需要创建多少个<code>fake</code>对象呢，首先，<code>Objective-C</code>对象实例在<code>Block</code>的<code>struct</code>中的位置是指针对齐的，所以我们可以获取<code>Block</code>结构体的大小，除以指针的大小取上即为需要创建的<code>fake</code>对象的数量,<code>Block</code>结构体的<code>size</code>可以通过<code>block-&gt;descriptor-&gt;size</code>来获取。</p>
<p>得到需要创建<code>fake</code>对象的数量<code>count</code>后，创建一个数组，再创建<code>count</code>个<code>fake</code>对象，将数组指针传入<code>dispose_helper</code>即可。对于调用了<code>release</code>方法的对象，记录其索引值，通过访问<code>block[index]</code>即可拿到真正的<code>Objective-C</code>对象实例。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><hr>
<p>如上所说的捕获的<code>Objective-C</code>对象实例，不包括使用<code>__block</code>创建的实例，因为使用<code>__block</code>创建的变量，会加一层间接层，并不会在<code>Block</code>结构体中创建指向实例对象的变量，而是指向另一个间接层结构体。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a href="https://clang.llvm.org/docs/Block-ABI-Apple.html" target="_blank" rel="external">https://clang.llvm.org/docs/Block-ABI-Apple.html</a></li>
<li><a href="https://github.com/mikeash/Circle/blob/master/Circle/CircleIVarLayout.m" target="_blank" rel="external">https://github.com/mikeash/Circle/blob/master/Circle/CircleIVarLayout.m</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Block管理Objective-C对象实例的原理&quot;&gt;&lt;a href=&quot;#Block管理Objective-C对象实例的原理&quot; class=&quot;headerlink&quot; title=&quot;Block管理Objective-C对象实例的原理&quot;&gt;&lt;/a&gt;Block管理&lt;cod
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Block" scheme="https://zhongwuzw.github.io/tags/Block/"/>
    
  </entry>
  
  <entry>
    <title>iOS内存管理之Swapped Memory</title>
    <link href="https://zhongwuzw.github.io/2018/06/13/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BSwapped-Memory/"/>
    <id>https://zhongwuzw.github.io/2018/06/13/iOS内存管理之Swapped-Memory/</id>
    <published>2018-06-13T09:00:10.000Z</published>
    <updated>2018-06-13T10:05:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swap-Space"><a href="#Swap-Space" class="headerlink" title="Swap Space"></a>Swap Space</h2><hr>
<p><code>Linux</code>、<code>Macos</code>等系统有一个<code>Swap space</code>的概念，当物理内存紧张时，系统会将<code>inactive</code>的<code>pages</code>放到<code>Swap Space</code>，<code>Swap Space</code>为磁盘上的某个区域，一般是文件形式，这样能节省出来一部分的物理内存，不过，当我们需要访问已经放到磁盘中的内存时，由于已经不在物理内存中，会引发缺页中断，需要再次从磁盘中重新读取，所以会比直接从内存获取要慢。</p>
<p>不过<code>iOS</code>系统并没有<code>Swap Space</code>，原因可能有二，其一是<code>iPhone</code>的<code>Flash</code>闪存空间受限；其二是<code>CPU</code>受限，因为手机的<code>CPU</code>相比电脑还是有一定差距。</p>
<h2 id="Swapped-Size"><a href="#Swapped-Size" class="headerlink" title="Swapped Size"></a>Swapped Size</h2><hr>
<p><code>iOS</code>中，内存分为两种，一种为<code>Clean memory</code>，另一种为<code>Dirty memory</code>；<br><code>Clean memory</code>的<code>page</code>可以换出，既磁盘中有其对应内容，系统可以在内存紧张时将<code>Clean memory</code>的<code>page</code>换出，当再次访问时，可以重新从磁盘中读取，我们使用的图片、<code>mapped files</code>、<code>Framework</code>的数据段常量以及代码段等，这些都是<code>Clean memory</code>。<br><code>Dirty memory</code>是无法换出的，我们所有的堆上的分配等都是属于<code>Dirty memory</code>,所以我们一定要尽可能的减少<code>Dirty memory</code>的使用。</p>
<p>从<code>iOS7</code>开始，<code>iOS</code>引入了<code>Compression</code>的概念，如下图为<code>Instruments</code>的<code>Allocations template</code>，我们可以从标红的地方看到，有一个<code>Swapped Size</code>的指标，从<a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf" target="_blank" rel="external">WWDC 2018 416</a>得知，该指标的含义为<code>compression size</code>，即系统可以把最近最少使用的<code>Dirty memory</code>进行压缩，这样可以腾出一些<code>pages</code>供使用，当再次需要访问内容时，系统将其解压，这时，原来内容占多少<code>pages</code>，解压后同样会是相同数量的<code>pages</code>。</p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/b14b5edf5c614b290b9ad0d5cdcbb81c1a6583d7/images/blog/ios-swapped-size.png" alt=""></p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/b14b5edf5c614b290b9ad0d5cdcbb81c1a6583d7/images/blog/ios-memory-compression.png" alt=""></p>
<p>上图为<code>JetsamEvent</code>的log，展示了<code>compression size</code>等指标，<code>jetsam_thread</code>线程运行在阻塞的循环中，当唤起时，根据内存列表来<code>kill</code>掉处于<code>top</code>的进程，当内存足够时，再次进入休眠。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf" target="_blank" rel="external">https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf</a></li>
<li><a href="http://newosxbook.com/articles/MemoryPressure.html" target="_blank" rel="external">http://newosxbook.com/articles/MemoryPressure.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Swap-Space&quot;&gt;&lt;a href=&quot;#Swap-Space&quot; class=&quot;headerlink&quot; title=&quot;Swap Space&quot;&gt;&lt;/a&gt;Swap Space&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Linux&lt;/code&gt;、&lt;code&gt;Macos&lt;/c
    
    </summary>
    
      <category term="iOS开发-其它" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="内存" scheme="https://zhongwuzw.github.io/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>iOS知识小集之main-queue!=main-thread</title>
    <link href="https://zhongwuzw.github.io/2018/05/22/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8Bmain-queue-main-thread/"/>
    <id>https://zhongwuzw.github.io/2018/05/22/iOS知识小集之main-queue-main-thread/</id>
    <published>2018-05-22T12:55:25.000Z</published>
    <updated>2018-05-22T13:47:38.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GCD-main-queue和main-thread的关系"><a href="#GCD-main-queue和main-thread的关系" class="headerlink" title="GCD main queue和main thread的关系"></a>GCD <code>main queue</code>和<code>main thread</code>的关系</h2><hr>
<p><code>dispatch_get_main_queue()</code>返回<code>main queue</code>，该队列会被绑定到<code>main thread</code>，所以我们如果我们将<code>block</code>提交到<code>main queue</code>，那么该<code>block</code>将会在主线程中执行。</p>
<h2 id="dispatch-sync-queue-block-向-main-queue提交block"><a href="#dispatch-sync-queue-block-向-main-queue提交block" class="headerlink" title="dispatch_sync(queue, block)向 main queue提交block"></a><code>dispatch_sync(queue, block)</code>向 <code>main queue</code>提交<code>block</code></h2><hr>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// Current thread is main thread</span></div><div class="line"><span class="selector-tag">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">        NSLog(@"Is main thread? %d", <span class="selector-attr">[NSThread isMainThread]</span>);</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line"><span class="comment">/// output:</span></div><div class="line"><span class="comment">/// "Is main thread? 1"</span></div></pre></td></tr></table></figure>
<p>大家有没有注意到，<code>Log</code>输出表明执行<code>Block</code>时的线程为主线程，根据我们以往的经验，<code>dispatch_get_global_queue</code>获取到的队列，队列中的<code>Block</code>应该是在<code>Secondly thread</code>中执行，为什么这里会是在主线程中呢。</p>
<p>答案就是在<code>dispatch_sync</code>语句，<code>libdispatch</code>在<a href="https://github.com/apple/swift-corelibs-libdispatch/commit/e64e4b962e1f356d7561e7a6103b424f335d85f6" target="_blank" rel="external">commit</a>中进行了优化，只要目标<code>queue</code>不是<code>main queue</code>，那么提交的<code>Block</code>就会直接在原线程中执行，这就能解释为什么上面的<code>demo</code>程序中输出的<code>Log</code>显示是主线程。</p>
<p>那么，这种会不会有潜在的问题呢？</p>
<h2 id="isMainThread带来的潜在问题"><a href="#isMainThread带来的潜在问题" class="headerlink" title="isMainThread带来的潜在问题"></a><code>isMainThread</code>带来的潜在问题</h2><hr>
<p>首先，我们看一个<a href="http://www.openradar.me/24025596" target="_blank" rel="external">Radar</a>，大概意思是，即使<code>MapKit</code>框架的<code>addOverlay</code>方法在主线程执行，但是由于其不是在<code>main queue</code>中执行的，会导致<code>Crash</code>，这是因为<code>MapKit</code>内部在<code>main queue</code>中使用<code>dispatch_queue_set_specific</code>设置了数据，当你在其它队列中执行时，会由于没有该数据从而导致<code>Crash</code>。</p>
<h2 id="避免使用isMainThread"><a href="#避免使用isMainThread" class="headerlink" title="避免使用isMainThread"></a>避免使用<code>isMainThread</code></h2><hr>
<p>所以，我们需要避免使用<code>isMainThread</code>，而是判断是不是<code>main queue</code>，我们可以使用两种方法来判断：</p>
<ol>
<li>使用<code>dispatch_queue_set_specific</code>在<code>main queue</code>上设置<code>flag</code>，然后做判断，有该<code>flag</code>即为<code>main queue</code>.</li>
<li>判断<code>dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())</code>，<code>main queue</code>设置了<code>label</code>，可以通过其来判断。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ol>
<li><code>main queue</code>中的<code>Block</code>一定在主线程中执行。</li>
<li>主线程可以对应多个<code>queue</code>，既可以有任意的队列，其<code>Block</code>可以在主线程中执行。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083" target="_blank" rel="external">https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083</a></li>
<li><a href="http://www.openradar.me/24025596" target="_blank" rel="external">http://www.openradar.me/24025596</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GCD-main-queue和main-thread的关系&quot;&gt;&lt;a href=&quot;#GCD-main-queue和main-thread的关系&quot; class=&quot;headerlink&quot; title=&quot;GCD main queue和main thread的关系&quot;&gt;&lt;/a
    
    </summary>
    
      <category term="iOS开发-其它" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="GCD" scheme="https://zhongwuzw.github.io/tags/GCD/"/>
    
      <category term="tips" scheme="https://zhongwuzw.github.io/tags/tips/"/>
    
      <category term="知识小集" scheme="https://zhongwuzw.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS知识小集之Swift闭包作为Objective-C方法参数</title>
    <link href="https://zhongwuzw.github.io/2018/05/05/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8BSwift%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BAObjective-C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0/"/>
    <id>https://zhongwuzw.github.io/2018/05/05/iOS知识小集之Swift闭包作为Objective-C方法参数/</id>
    <published>2018-05-05T15:30:30.000Z</published>
    <updated>2018-05-22T12:25:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Swift闭包作为Objective-C方法参数"><a href="#Swift闭包作为Objective-C方法参数" class="headerlink" title="Swift闭包作为Objective-C方法参数"></a>Swift闭包作为Objective-C方法参数</h2><hr>
<p>在<code>Swift</code>开发时，有时我们需要调用带有<code>Block</code>参数的<code>Objective-C</code>方法，比如，我们通过<code>perform(_:with:afterDelay:inModes:)</code>来在特定的<code>Runloop</code>模式下运行某<code>selector</code>，如下所示，<code>doAnimation</code>方法接收一个<code>Optional</code>的<code>Block</code>，注意，该方法标注了<code>@objc</code>，所以是<code>Objective-C</code>方法，<code>animationBlock</code>参数为<code>Objective-C</code>的<code>Block</code>，那么我们怎么将<code>Swift</code>的<code>Closure</code>转化为<code>Block</code>呢，方法就是使用<code>@convention(block)</code>来声明兼容<code>Objective-C</code> <code>Block</code>的<code>Closure</code>，如下<code>[1]</code>所示：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocationMessageCell</span>: <span class="title">UICollectionViewCell</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">func</span> <span class="title">callSEL</span><span class="params">()</span></span> &#123;</div><div class="line">        <span class="keyword">let</span> block: <span class="meta">@convention</span>(block) (<span class="type">UIImageView</span>) -&gt; <span class="type">Void</span> = &#123; <span class="number">_</span> <span class="keyword">in</span>    <span class="comment">// [1]</span></div><div class="line">        ....</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">self</span>.perform(#selector(<span class="type">LocationMessageCell</span>.doAnimation(with:)), with: block, afterDelay: <span class="number">0</span>, inModes: [.defaultRunLoopMode])</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="meta">@objc</span> <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">doAnimation</span><span class="params">(with animationBlock: <span class="params">(<span class="params">(UIImageView)</span></span></span></span> -&gt; <span class="type">Void</span>)!) &#123;</div><div class="line">        ....</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>除了显式的用<code>@convention(block)</code>来声明，我们也可以直接使用闭包，如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">UIView</span><span class="selector-class">.animate</span>(<span class="attribute">withDuration</span>: <span class="number">0.1</span>, <span class="attribute">animations</span>: &#123;</div><div class="line">    ...                </div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>注意，之所以我没有在之前的例子进行修改，是因为<code>func perform(_ aSelector: Selector, with anArgument: Any?, afterDelay delay: TimeInterval, inModes modes: [RunLoopMode])</code>的<code>anArgument</code>参数类型为<code>Any?</code>，编译器没有进行自动转换，这种情况只能显式的声明<code>@convention(block)</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Swift闭包作为Objective-C方法参数&quot;&gt;&lt;a href=&quot;#Swift闭包作为Objective-C方法参数&quot; class=&quot;headerlink&quot; title=&quot;Swift闭包作为Objective-C方法参数&quot;&gt;&lt;/a&gt;Swift闭包作为Objec
    
    </summary>
    
      <category term="iOS开发-其它" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://zhongwuzw.github.io/tags/Swift/"/>
    
      <category term="tips" scheme="https://zhongwuzw.github.io/tags/tips/"/>
    
      <category term="Closure" scheme="https://zhongwuzw.github.io/tags/Closure/"/>
    
      <category term="知识小集" scheme="https://zhongwuzw.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>iOS知识小集之为什么objc_msgSend()是用汇编实现的</title>
    <link href="https://zhongwuzw.github.io/2018/04/21/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88objc-msgSend-%E6%98%AF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%9A%84/"/>
    <id>https://zhongwuzw.github.io/2018/04/21/iOS知识小集之为什么objc-msgSend-是用汇编实现的/</id>
    <published>2018-04-21T15:07:30.000Z</published>
    <updated>2018-05-22T12:26:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><hr>
<p>在使用<code>Objective-C</code>调用方法时，我们将其称之为消息发送，这与我们用的<code>C</code>、<code>C++</code>等调用函数的说法不一样，原因就是<code>Objective-C</code>调用方法时，并不是简单的会在编译时得到函数指针，调用时直接使用该函数指针调用就行（<code>C++</code>有虚函数，包含一个<code>v-table</code>，可以实现简单的多态），而是会在调用的时候，运行时的去查找函数实现，比如，当我们发送<code>[objc foo]</code>时，编译器会将其转化为<code>objc_msgSend(objc, @selector(foo))</code>(注意，不一定都是转化为<code>objc_msgSend</code>，根据发送对象和返回类型，可转化为<code>objc_msgSendSuper</code>,<code>objc_msgSendSuper_stret</code>等)，<code>objc_msgSend</code>方法负责查找函数实现并调用返回结果，我们知道，<code>Objc Runtime</code>是<a href="https://github.com/zhongwuzw/objc4-cn" target="_blank" rel="external">开源</a>的，所以我们可以看一下源代码<code>objc_msgSend</code>的实现逻辑。</p>
<h2 id="objc-msgSend-使用汇编实现"><a href="#objc-msgSend-使用汇编实现" class="headerlink" title="objc_msgSend()使用汇编实现"></a>objc_msgSend()使用汇编实现</h2><hr>
<p>源码可参见<a href="https://github.com/zhongwuzw/objc4-cn/blob/087a6fd60e3cad2934163b26aa484640d6ff9467/runtime/Messengers.subproj/objc-msg-arm64.s#L286" target="_blank" rel="external">objc_msgSend源码</a>，我们发现，竟然不是用<code>C</code>实现的，而是使用的汇编语言，总结来说，原因有二：</p>
<ol>
<li>我们无法定义一个<code>C</code>函数，可以有可变的参数(可变参数是可以实现的，参考<code>printf</code>函数)并且可以调用任意的<code>C</code>函数指针，因为函数指针类型是在是无穷无尽的，根本就无法预先全部定义出来。<a id="more"></a></li>
<li>使用汇编另一个很重要的原因就是速度，首先，汇编就比<code>C</code>快，其次，通过使用汇编，可以免去大量局部变量拷贝的操作，参数会直接被存放在寄存器中，当找到<code>IMP</code>时，参数已经保存在了寄存器中，可以直接使用。</li>
</ol>
<h2 id="objc-msgSend-步骤总结"><a href="#objc-msgSend-步骤总结" class="headerlink" title="objc_msgSend()步骤总结"></a>objc_msgSend()步骤总结</h2><hr>
<p><code>objc_msgSend</code>步骤：</p>
<ol>
<li>获取传递进来的类对象</li>
<li>获取类用来缓存方法的cache</li>
<li>使用<code>selector</code>在cache中查找</li>
<li>如果cache中查找不到，则跳转到C代码(<code>_class_lookupMethodAndLoadCache3</code>)，进行slow search</li>
<li>调用方法的IMP</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2017-06-30-dissecting-objc_msgsend-on-arm64.html</a></li>
<li><a href="https://github.com/zhongwuzw/objc4-cn/blob/087a6fd60e3cad2934163b26aa484640d6ff9467/runtime/Messengers.subproj/objc-msg-arm64.s" target="_blank" rel="external">https://github.com/zhongwuzw/objc4-cn/blob/087a6fd60e3cad2934163b26aa484640d6ff9467/runtime/Messengers.subproj/objc-msg-arm64.s</a></li>
<li><a href="https://github.com/zhongwuzw/objc4-cn" target="_blank" rel="external">https://github.com/zhongwuzw/objc4-cn</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;消息发送&quot;&gt;&lt;a href=&quot;#消息发送&quot; class=&quot;headerlink&quot; title=&quot;消息发送&quot;&gt;&lt;/a&gt;消息发送&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在使用&lt;code&gt;Objective-C&lt;/code&gt;调用方法时，我们将其称之为消息发送，这与我们用的&lt;code&gt;C&lt;/code&gt;、&lt;code&gt;C++&lt;/code&gt;等调用函数的说法不一样，原因就是&lt;code&gt;Objective-C&lt;/code&gt;调用方法时，并不是简单的会在编译时得到函数指针，调用时直接使用该函数指针调用就行（&lt;code&gt;C++&lt;/code&gt;有虚函数，包含一个&lt;code&gt;v-table&lt;/code&gt;，可以实现简单的多态），而是会在调用的时候，运行时的去查找函数实现，比如，当我们发送&lt;code&gt;[objc foo]&lt;/code&gt;时，编译器会将其转化为&lt;code&gt;objc_msgSend(objc, @selector(foo))&lt;/code&gt;(注意，不一定都是转化为&lt;code&gt;objc_msgSend&lt;/code&gt;，根据发送对象和返回类型，可转化为&lt;code&gt;objc_msgSendSuper&lt;/code&gt;,&lt;code&gt;objc_msgSendSuper_stret&lt;/code&gt;等)，&lt;code&gt;objc_msgSend&lt;/code&gt;方法负责查找函数实现并调用返回结果，我们知道，&lt;code&gt;Objc Runtime&lt;/code&gt;是&lt;a href=&quot;https://github.com/zhongwuzw/objc4-cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;开源&lt;/a&gt;的，所以我们可以看一下源代码&lt;code&gt;objc_msgSend&lt;/code&gt;的实现逻辑。&lt;/p&gt;
&lt;h2 id=&quot;objc-msgSend-使用汇编实现&quot;&gt;&lt;a href=&quot;#objc-msgSend-使用汇编实现&quot; class=&quot;headerlink&quot; title=&quot;objc_msgSend()使用汇编实现&quot;&gt;&lt;/a&gt;objc_msgSend()使用汇编实现&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;源码可参见&lt;a href=&quot;https://github.com/zhongwuzw/objc4-cn/blob/087a6fd60e3cad2934163b26aa484640d6ff9467/runtime/Messengers.subproj/objc-msg-arm64.s#L286&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;objc_msgSend源码&lt;/a&gt;，我们发现，竟然不是用&lt;code&gt;C&lt;/code&gt;实现的，而是使用的汇编语言，总结来说，原因有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我们无法定义一个&lt;code&gt;C&lt;/code&gt;函数，可以有可变的参数(可变参数是可以实现的，参考&lt;code&gt;printf&lt;/code&gt;函数)并且可以调用任意的&lt;code&gt;C&lt;/code&gt;函数指针，因为函数指针类型是在是无穷无尽的，根本就无法预先全部定义出来。
    
    </summary>
    
      <category term="iOS开发-其它" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="tips" scheme="https://zhongwuzw.github.io/tags/tips/"/>
    
      <category term="知识小集" scheme="https://zhongwuzw.github.io/tags/%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>Goroutines vs 多线程</title>
    <link href="https://zhongwuzw.github.io/2018/01/30/Goroutines-vs-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zhongwuzw.github.io/2018/01/30/Goroutines-vs-多线程/</id>
    <published>2018-01-30T02:56:47.000Z</published>
    <updated>2018-01-30T04:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><a href="https://golang.google.cn" target="_blank" rel="external">Golang</a>是由<code>Google</code>开发，天生支持并发的语言。<code>Go</code>有一个<code>goroutine</code>的机制，当我们在调用函数前加上<code>go</code>关键字，那么就会创建一个<code>goroutine</code>来异步执行该函数，如：<code>go foo()</code>，以此来实现并发的功能。本文，我们将讨论一下<code>goroutine</code>和线程的区别。</p>
<h2 id="大小可调整的栈"><a href="#大小可调整的栈" class="headerlink" title="大小可调整的栈"></a>大小可调整的栈</h2><hr>
<p>线程可以在启动前设置栈的大小，启动后，线程的栈大小就固定了，所以带来的弊端就是浪费内存空间，因为很多时候并不需要这么多内存。<br>相比于线程，<code>goroutine</code>的栈空间是可调整的，<code>goroutine</code>创建时，通常只会分配<code>2KB</code>大小的栈，随着<code>goroutine</code>的运行，比如不断的递归，创建变量等，相应的栈空间也会增大，反之也会按需减小，一个<code>goroutine</code>最大可分配栈空间通常为<code>1GB</code>。</p>
<h2 id="goroutine-的调度"><a href="#goroutine-的调度" class="headerlink" title="goroutine 的调度"></a><code>goroutine</code> 的调度</h2><hr>
<p>线程由系统内核进行调度，系统为了实现并发，会不断的切换线程的执行，由此会带来线程的上下文切换。<br>而<code>Go</code>的运行时有一套自己的调度系统，使用<code>m:n</code>策略，既复用<code>m</code>个<code>goroutine</code>到<code>n</code>个线程，<code>Go</code>的调度器类似于内核调度器，区别是它仅管理单个<code>Go</code>程序创建的<code>goroutine</code>。<br>相比于线程，<code>Go</code>的调度器并不会周期性的被硬件定时器调用，而是<code>Go</code>自己来处理，比如，当一个<code>goroutine</code>调用<code>time.Sleep</code>或阻塞与通道、互斥操作时，调度器会将<code>goroutine</code>休眠，然后运行另外的<code>goroutine</code>，这些并不需要内核的上下文切换，所以重新调度一个<code>goroutine</code>的开销会小于重新调度线程的开销。</p>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><code>GOMAXPROCS</code></h2><hr>
<p><code>Go</code>的调度器使用一个名为<code>GOMAXPROCS</code>的参数来确定真正的线程数，其默认值为机器的<code>CPU</code>的数量，如一台机器有8个<code>CPU</code>,那么调度器会同时创建8个线程（<code>GOMAXPROCS</code>就是如上所说<code>m:n</code>中的<code>n</code>)。休眠或阻塞中<code>goroutine</code>不需要线程，但是对于阻塞在<code>I/O</code>或系统调用、正在调用非<code>Go</code>函数的<code>goroutine</code>来说，需要一个系统线程，不过不占用<code>GOMAXPROCS</code>。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a href="https://golang.google.cn" target="_blank" rel="external">https://golang.google.cn</a></li>
<li><a href="http://www.gopl.io" target="_blank" rel="external">http://www.gopl.io</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://golang.google.cn&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
    
    </summary>
    
      <category term="Go" scheme="https://zhongwuzw.github.io/categories/Go/"/>
    
    
      <category term="Go" scheme="https://zhongwuzw.github.io/tags/Go/"/>
    
      <category term="并发" scheme="https://zhongwuzw.github.io/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C++之内存管理</title>
    <link href="https://zhongwuzw.github.io/2017/11/16/Objective-C-%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://zhongwuzw.github.io/2017/11/16/Objective-C-之内存管理/</id>
    <published>2017-11-16T02:28:46.000Z</published>
    <updated>2017-11-16T03:37:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Objective-C-内存管理"><a href="#Objective-C-内存管理" class="headerlink" title="Objective-C++内存管理"></a>Objective-C++内存管理</h2><hr>
<p>在项目开发时，有时会使用<code>C++</code>来进行混合开发，因为<code>C++</code>有很好的跨平台及性能优势。我们可以将<code>C++</code>对象作为<code>Objective-C</code>的属性或者反过来<code>Objective-C</code>作为<code>C++</code>对象的成员，当我们需要在App中使用C++库时，会很有用。</p>
<p>当我们的文件同时使用了<code>Objective-C</code>和<code>C++</code>时，需要告知编译器来进行处理，方法为将该文件的后缀从<code>.m</code>改为<code>.mm</code>。</p>
<p>如下示例展示了<code>Objective-C</code>和<code>C++</code>互相作为成员变量来关联：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// Forward declare so that everything works below</span></div><div class="line"><span class="class"><span class="keyword">@class</span> <span class="title">ObjcClass</span>;</span></div><div class="line"><span class="keyword">class</span> CppClass;</div><div class="line"></div><div class="line"><span class="comment">// C++ class with an Objective-C member variable</span></div><div class="line"><span class="keyword">class</span> CppClass &#123;</div><div class="line">  public:</div><div class="line">    ObjcClass *objcClass;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// Objective-C class with a C++ object as a property</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ObjcClass</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) std::shared_ptr&lt;CppClass&gt; cppClass;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ObjcClass</span></span></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// Using the two classes above</span></div><div class="line">std::shared_ptr&lt;CppClass&gt; cppClass(new CppClass());</div><div class="line">ObjcClass *objcClass = [[ObjcClass alloc] init];</div><div class="line"></div><div class="line">cppClass-&gt;objcClass = objcClass;</div><div class="line">objcClass.cppClass = cppClass;</div></pre></td></tr></table></figure>
<p>如上，我们注意到，属性声明成了<code>assign</code>，而不是我们通常使用的<code>strong</code>、<code>weak</code>，原因就是对于非<code>Objective-C</code>类型对象来说是没有意义的，编译器无法<code>retain</code>或<code>release</code>一个<code>C++</code>对象，因为它不是一个<code>Objective-C</code>对象类型。</p>
<p>尽管声明属性为<code>assign</code>，但是内存管理依然能正确处理；不过这里要注意的是，如果我们使用原始指针来保存，这时候就需要自己进行内存管理了。</p>
<p><code>Objective-C</code>对象实例总是在堆上分配，但是<code>C++</code>实例可以在栈或堆上。所以我们把分配在栈上的<code>C++</code>实例赋值给<code>Objective-C</code>的成员变量时，就有点奇怪，不过不用担心，它其实会放到堆上，因为整个<code>Objective-C</code>对象都是在堆上的。编译器实现这个转化的方式为：在<code>alloc</code>和<code>dealloc</code>方法中构建和析构<code>C++</code>对象，分别调用<code>object_cxxConstruct</code>、<code>object_cxxDestruct</code>方法，来处理<code>C++</code>对象。</p>
<p>所以，对于所有基于栈的<code>C++</code>对象，不需要担心内存的问题，编译器自动接管。但是再强调一下，基于堆的<code>C++</code>对象，需要手动管理内存，如在<code>dealloc</code>中<code>delete``C++</code>对象。</p>
<p><code>Game Over!!!</code></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Objective-C-内存管理&quot;&gt;&lt;a href=&quot;#Objective-C-内存管理&quot; class=&quot;headerlink&quot; title=&quot;Objective-C++内存管理&quot;&gt;&lt;/a&gt;Objective-C++内存管理&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在项目开发时，
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="C++" scheme="https://zhongwuzw.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>聊聊dealloc</title>
    <link href="https://zhongwuzw.github.io/2017/09/21/%E8%81%8A%E8%81%8Adealloc/"/>
    <id>https://zhongwuzw.github.io/2017/09/21/聊聊dealloc/</id>
    <published>2017-09-21T09:52:34.000Z</published>
    <updated>2017-09-25T03:25:49.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<blockquote>
<p>所有代码注释可在<a href="https://github.com/zhongwuzw/ObjC-Runtime" target="_blank" rel="external">Objc-Runtime</a>中查看</p>
</blockquote>
<p>在<code>iOS</code>开发中，我们经常会通过<code>dealloc</code>来判断对象实例是否被释放，依据是当对象实例的引用计数变为0时，运行时会调用对象实例的<code>dealloc</code>方法，我们可以利用该方法做一些扫尾的工作。</p>
<h2 id="dealloc调用时机"><a href="#dealloc调用时机" class="headerlink" title="dealloc调用时机"></a>dealloc调用时机</h2><hr>
<p><code>Objective-C</code>的引用计数管理使用两种方式相结合，<code>sidetable</code>和<code>isa</code>指针（指针并不是对象的真正内存地址，而是某些位用来进行了一些标志位的存放）；接下来，我将以<code>sidetable</code>进行<code>release</code>来讨论<code>dealloc</code>的调用，直接上代码，如下<code>sidetable_release</code>（下文所有都会用<code>sidetable_release</code>来讨论）函数会在给对象发送<code>release</code>消息的时候调用，<code>sidetable_release</code>方法首先获取对象的引用计数，对引用计数相关标志位做操作，若对象实例可以被释放，将通过<code>objc_msgSend</code>发送<code>SEL_dealloc</code>消息，既调用对象的<code>dealloc</code>方法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">uintptr_t</span></div><div class="line">objc_object::sidetable_release(<span class="keyword">bool</span> performDealloc)</div><div class="line">&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_NONPOINTER_ISA</span></div><div class="line">    assert(!isa.nonpointer);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">    SideTable&amp; table = SideTables()[<span class="keyword">this</span>];</div><div class="line"></div><div class="line">    <span class="keyword">bool</span> do_dealloc = <span class="literal">false</span>;</div><div class="line"></div><div class="line">    table.lock();</div><div class="line">    RefcountMap::iterator it = table.refcnts.find(<span class="keyword">this</span>);</div><div class="line">    <span class="keyword">if</span> (it == table.refcnts.end()) &#123;</div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        table.refcnts[<span class="keyword">this</span>] = SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</div><div class="line">        <span class="comment">// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don't change it.</span></div><div class="line">        do_dealloc = <span class="literal">true</span>;</div><div class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</div><div class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</div><div class="line">    &#125;</div><div class="line">    table.unlock();</div><div class="line">    <span class="comment">// 进行释放操作，调用dealloc</span></div><div class="line">    <span class="keyword">if</span> (do_dealloc  &amp;&amp;  performDealloc) &#123;</div><div class="line">        ((<span class="keyword">void</span>(*)(objc_object *, SEL))objc_msgSend)(<span class="keyword">this</span>, SEL_dealloc);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> do_dealloc;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><code>dealloc</code>方法的实现如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">- <span class="params">(void)</span>dealloc &#123;</div><div class="line">    _objc_rootDealloc<span class="params">(self)</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>直接调用<code>_objc_rootDealloc</code>方法来做处理，我们省略一些细节处理，通常情况下，<code>dealloc</code>方法最终会调用<code>objc_dispose</code>方法，内部又调用<code>objc_destructInstance</code>方法来进行析构操作，析构完成后将内存释放掉。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">id</span> </div><div class="line">object_dispose(<span class="keyword">id</span> obj)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line"></div><div class="line">    objc_destructInstance(obj);</div><div class="line">    <span class="comment">// 做完各种析构操作后释放obj的内存</span></div><div class="line">    free(obj);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">void *objc_destructInstance(id obj) </div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (obj) &#123;</div><div class="line">        <span class="comment">// Read all of the flags at once for performance.</span></div><div class="line">        <span class="keyword">bool</span> cxx = obj-&gt;hasCxxDtor();</div><div class="line">        <span class="keyword">bool</span> assoc = obj-&gt;hasAssociatedObjects();</div><div class="line"></div><div class="line">        <span class="comment">// This order is important.</span></div><div class="line">        <span class="keyword">if</span> (cxx) object_cxxDestruct(obj);   <span class="comment">// 调用C++析构器</span></div><div class="line">        <span class="keyword">if</span> (assoc) _object_remove_assocations(obj); <span class="comment">// 移除对象相关的关联引用</span></div><div class="line">        obj-&gt;clearDeallocating();   <span class="comment">// 进行ARC相关操作，如weak置nil，清理计数位</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="并发赋值"><a href="#并发赋值" class="headerlink" title="并发赋值"></a>并发赋值</h2><hr>
<p>考虑如下代码，我们来模拟并发的对变量<code>obj</code>进行赋值。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">__block <span class="built_in">NSObject</span> *obj = [<span class="built_in">NSObject</span> new];</div><div class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</div><div class="line">        obj = [<span class="built_in">NSObject</span> new];</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</div><div class="line">    obj = [<span class="built_in">NSObject</span> new];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行如上代码，我们发现，很快程序就会崩溃，异常为<code>EXC_BAD_ACCESS</code>，既访问已释放的内存地址，异常栈如下，在调用<code>objc_msgSend</code>发送<code>SEL_dealloc</code>方法时异常，而该方法正是在如上的<code>objc_object::sidetable_release</code>中被调用的，也就是<code>release</code>方法调用过程中。最终的原因就是对已释放的对象实例再次进行<code>release</code>操作。</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="number">0x106463a00</span> &lt;+<span class="number">156</span>&gt;: callq  <span class="number">0x1064653e8</span>               <span class="comment">; objc::DenseMapBase&lt;objc::DenseMap&lt;DisguisedPtr&lt;objc_object&gt;, unsigned long, true, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt; &gt;, DisguisedPtr&lt;objc_object&gt;, unsigned long, objc::DenseMapInfo&lt;DisguisedPtr&lt;objc_object&gt; &gt;, true&gt;::FindAndConstruct(DisguisedPtr&lt;objc_object&gt; const&amp;)</span></div><div class="line"><span class="number">0x106463a05</span> &lt;+<span class="number">161</span>&gt;: <span class="keyword">movq</span>   <span class="number">$0</span>x2, <span class="number">0x8</span>(%rax)</div><div class="line"><span class="number">0x106463a0d</span> &lt;+<span class="number">169</span>&gt;: movl   -<span class="number">0x2c</span>(%rbp), %ebx</div><div class="line"><span class="number">0x106463a10</span> &lt;+<span class="number">172</span>&gt;: <span class="keyword">movq</span>   %r15, %rdi</div><div class="line"><span class="number">0x106463a13</span> &lt;+<span class="number">175</span>&gt;: callq  <span class="number">0x1064669fa</span>               <span class="comment">; symbol stub for: os_unfair_lock_unlock</span></div><div class="line"><span class="number">0x106463a18</span> &lt;+<span class="number">180</span>&gt;: testb  %bl, %bl</div><div class="line"><span class="number">0x106463a1a</span> &lt;+<span class="number">182</span>&gt;: <span class="keyword">je</span>     <span class="number">0x106463a2e</span>               <span class="comment">; &lt;+202&gt;</span></div><div class="line"><span class="number">0x106463a1c</span> &lt;+<span class="number">184</span>&gt;: leaq   <span class="number">0x55a8ad</span>(%rip), %rax      <span class="comment">; SEL_dealloc</span></div><div class="line"><span class="number">0x106463a23</span> &lt;+<span class="number">191</span>&gt;: <span class="keyword">movq</span>   (%rax), %rsi // 在这访问了已释放的内存地址</div><div class="line"><span class="number">0x106463a26</span> &lt;+<span class="number">194</span>&gt;: <span class="keyword">movq</span>   %r14, %rdi</div><div class="line"><span class="number">0x106463a29</span> &lt;+<span class="number">197</span>&gt;: callq  <span class="number">0x106465940</span>               <span class="comment">; objc_msgSend</span></div><div class="line"><span class="number">0x106463a2e</span> &lt;+<span class="number">202</span>&gt;: movl   <span class="number">$0</span>x1, %eax</div><div class="line"><span class="number">0x106463a33</span> &lt;+<span class="number">207</span>&gt;: <span class="keyword">jmp</span>    <span class="number">0x106463a4c</span>               <span class="comment">; &lt;+232&gt;</span></div></pre></td></tr></table></figure>
<p>为什么会导致这样的结果呢？原因其实是，对属性的赋值操作并不是原子操作，对属性的赋值其实是调用属性的<code>setter</code>方法，默认<code>setter</code>代码实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)setObj:(<span class="built_in">NSObject</span> *)obj &#123;</div><div class="line">    <span class="keyword">if</span> (obj != _obj) &#123;          <span class="comment">// 1</span></div><div class="line">        <span class="keyword">id</span> oldValue = _obj;     <span class="comment">// 2</span></div><div class="line">        _obj = [obj <span class="keyword">retain</span>];    <span class="comment">// 3</span></div><div class="line">        [oldValue release];     <span class="comment">// 4</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们考虑两个线程同时进行<code>setObj:</code>赋值操作，当走到第4步时，两个线程同时尝试进行<code>release</code>操作，结果是一个线程成功的释放对象，而另一个线程会在<code>release</code>函数调用过程中访问已经释放的内存区域，这就导致了崩溃。</p>
<h2 id="dealloc在哪个线程被调用"><a href="#dealloc在哪个线程被调用" class="headerlink" title="dealloc在哪个线程被调用"></a>dealloc在哪个线程被调用</h2><hr>
<p><code>dealloc</code>并不总是在主线程中被调用，从如上<code>sidetable_release</code>方法，我们可得知，其调用线程为最后一个调用<code>release</code>方法的线程，当需要释放对象时，向对象实例发送<code>SEL_dealloc</code>（即<code>dealloc</code>）消息。</p>
<p>也就是说,<code>dealloc</code>方法有可能在任何线程被调用，这就需要注意一点，就是在<code>dealloc</code>中进行<code>UIKit</code>相关<code>API</code>的操作（<code>UIKit</code>相关<code>API</code>只能在主线程操作）。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW13" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmPractical.html#//apple_ref/doc/uid/TP40004447-SW13</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;所有代码注释可在&lt;a href=&quot;https://github.com/zhongwuzw/ObjC-Runtime&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Objc-Runtime&lt;/a&gt;中查看&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;iOS&lt;/code&gt;开发中，我们经常会通过&lt;code&gt;dealloc&lt;/code&gt;来判断对象实例是否被释放，依据是当对象实例的引用计数变为0时，运行时会调用对象实例的&lt;code&gt;dealloc&lt;/code&gt;方法，我们可以利用该方法做一些扫尾的工作。&lt;/p&gt;
&lt;h2 id=&quot;dealloc调用时机&quot;&gt;&lt;a href=&quot;#dealloc调用时机&quot; class=&quot;headerlink&quot; title=&quot;dealloc调用时机&quot;&gt;&lt;/a&gt;dealloc调用时机&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt;的引用计数管理使用两种方式相结合，&lt;code&gt;sidetable&lt;/code&gt;和&lt;code&gt;isa&lt;/code&gt;指针（指针并不是对象的真正内存地址，而是某些位用来进行了一些标志位的存放）；接下来，我将以&lt;code&gt;sidetable&lt;/code&gt;进行&lt;code&gt;release&lt;/code&gt;来讨论&lt;code&gt;dealloc&lt;/code&gt;的调用，直接上代码，如下&lt;code&gt;sidetable_release&lt;/code&gt;（下文所有都会用&lt;code&gt;sidetable_release&lt;/code&gt;来讨论）函数会在给对象发送&lt;code&gt;release&lt;/code&gt;消息的时候调用，&lt;code&gt;sidetable_release&lt;/code&gt;方法首先获取对象的引用计数，对引用计数相关标志位做操作，若对象实例可以被释放，将通过&lt;code&gt;objc_msgSend&lt;/code&gt;发送&lt;code&gt;SEL_dealloc&lt;/code&gt;消息，既调用对象的&lt;code&gt;dealloc&lt;/code&gt;方法。&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;19&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;20&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;21&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;22&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;23&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;24&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;25&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;26&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;27&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;28&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;29&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;uintptr_t&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;objc_object::sidetable_release(&lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; performDealloc)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;if&lt;/span&gt; SUPPORT_NONPOINTER_ISA&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    assert(!isa.nonpointer);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;endif&lt;/span&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    SideTable&amp;amp; table = SideTables()[&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;];&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;bool&lt;/span&gt; do_dealloc = &lt;span class=&quot;literal&quot;&gt;false&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    table.lock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    RefcountMap::iterator it = table.refcnts.find(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (it == table.refcnts.end()) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        do_dealloc = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        table.refcnts[&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;] = SIDE_TABLE_DEALLOCATING;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (it-&amp;gt;second &amp;lt; SIDE_TABLE_DEALLOCATING) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;// SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#39;t change it.&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        do_dealloc = &lt;span class=&quot;literal&quot;&gt;true&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        it-&amp;gt;second |= SIDE_TABLE_DEALLOCATING;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125; &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (! (it-&amp;gt;second &amp;amp; SIDE_TABLE_RC_PINNED)) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        it-&amp;gt;second -= SIDE_TABLE_RC_ONE;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    table.unlock();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;// 进行释放操作，调用dealloc&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (do_dealloc  &amp;amp;&amp;amp;  performDealloc) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        ((&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt;(*)(objc_object *, SEL))objc_msgSend)(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;, SEL_dealloc);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; do_dealloc;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>实现Swift的Array</title>
    <link href="https://zhongwuzw.github.io/2017/09/01/%E5%AE%9E%E7%8E%B0Swift%E7%9A%84Array/"/>
    <id>https://zhongwuzw.github.io/2017/09/01/实现Swift的Array/</id>
    <published>2017-09-01T02:16:46.000Z</published>
    <updated>2017-09-03T15:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>当我们从<code>Obj-C</code>转到<code>Swift</code>时，会发现<code>Swift</code>提供的数据结构大量使用值语义，如<code>Array</code>、<code>Dictionary</code>等，今天，我们将实现<code>Array</code>的基本功能，来理解值语义以及写时复制。</p>
<h2 id="值和引用语义"><a href="#值和引用语义" class="headerlink" title="值和引用语义"></a>值和引用语义</h2><hr>
<p>在实现之前，我们来简单讨论一下值语义和引用语义的区别。当我们使用<code>Obj-C</code>及大多数其他面向对象语言开发时，经常会使用对象指针或引用，而这就是常说的引用语义，我们可以赋值一个对象实例的引用给一个变量：</p>
<p><code>MyClass *a = ...;</code></p>
<p>接着，可以将该变量赋值给另一个变量：</p>
<p><code>MyClass *b = a;</code></p>
<p>此时，<code>a</code>和<code>b</code>将指向同一个对象，如果指向的对象是可变的，当我们修改对象的内容时，两者对其都可见。</p>
<p>值语义相对比较简单，我们使用的如<code>int</code>、<code>struct</code>等都是值语义，声明为值语义的变量，其直接指向真正的值，而不是值的指针。所以当我们进行赋值时，将得到值的拷贝，如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">int a = <span class="number">42</span><span class="comment">;</span></div><div class="line">int <span class="keyword">b </span>= a<span class="comment">;</span></div><div class="line"><span class="keyword">b++;</span></div></pre></td></tr></table></figure>
<p>此时，<code>b</code>的值为<code>43</code>，而<code>a</code>依然为<code>42</code>。</p>
<p>在<code>Swift</code>中，<code>class</code>类型仍然是引用语义，<code>struct</code>则为值语义，所以，如果对<code>class</code>类型进行赋值时，将得到一个指向同一个实例的引用，对实例对象内容的修改将对所有的引用可见；使用<code>struct</code>时，则不会，每个变量之间都是独立的。</p>
<p>对于使用过<code>Obj-C</code>开发过的人来说，转到<code>Swift</code>使用其提供的数组和字典时，可能会不习惯，因为<code>Swift</code>中两者已经变成了值语义，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</div><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = <span class="selector-tag">a</span></div><div class="line"><span class="selector-tag">b</span>.append(<span class="number">4</span>)</div></pre></td></tr></table></figure>
<p>对于大多数语言，如上代码的结果一般都是<code>a</code>和<code>b</code>都指向同一个数组<code>[1, 2, 3, 4]</code>。而在<code>Swift</code>中，<code>a</code>指向<code>[1, 2, 3]</code>，<code>b</code>则指向<code>[1, 2, 3, 4]</code>。</p>
<h2 id="实现值语义"><a href="#实现值语义" class="headerlink" title="实现值语义"></a>实现值语义</h2><hr>
<p>如果对象包含固定数量的数据，那么实现就比较简单：我们直接将数据放到<code>struct</code>中即可。比如想要一个2D <code>Point</code>类型且满足值语义，可以创建一个<code>struct</code>包含<code>x``y</code>的值：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">struct Point &#123;</div><div class="line">    <span class="built_in">var</span> <span class="symbol">x:</span> <span class="built_in">Int</span></div><div class="line">    <span class="built_in">var</span> <span class="symbol">y:</span> <span class="built_in">Int</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>固定数量实现起来比较简单，但是我们使用的<code>Array</code>，它的个数不定，我们不可能直接把所有数组元素放到<code>struct</code>中，所以，我们需要创建一个指针，用来指向数组元素的内存：</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Array</span>&lt;T&gt; </span>&#123;</div><div class="line">    var ptr: UnsafeMutablePointer&lt;T&gt;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，有这还不够，我们还需要针对<code>struct</code>的赋值和销毁做一些操作；当<code>struct</code>被赋值时，需要对新的<code>struct</code>的<code>ptr</code>元素赋值，这时候需要将原<code>struct</code>的<code>ptr</code>指向的所有元素拷贝到一组新的内存块中，并将新的<code>struct</code>的<code>ptr</code>指向新的第一个元素的地址。当<code>struct</code>销毁时，其指针指向的元素占用的内存同样需要被释放。而这两个需求，<code>Swift</code>的<code>struct</code>并没有提供自定义方法可以实现。</p>
<p>由于<code>class</code>有<code>deinit</code>方法，所以析构功能可以通过<code>class</code>来实现，指针指向的内容可以在<code>deinit</code>中进行处理，但是<code>class</code>又不是值语义的，不过我们依然可以解决，既外封装<code>struct</code>，使用<code>struct</code>作为外部接口进行数组的使用，如下：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">class ArrayImpl<span class="symbol">&lt;T&gt;</span> &#123;</div><div class="line">    var <span class="keyword">ptr</span>: UnsafeMutablePointer<span class="symbol">&lt;T&gt;</span></div><div class="line"></div><div class="line">    deinit &#123;</div><div class="line">        <span class="keyword">ptr</span>.destroy(...)</div><div class="line">        <span class="keyword">ptr</span>.dealloc(...)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">struct Array<span class="symbol">&lt;T&gt;</span> &#123;</div><div class="line">    var imp<span class="variable">l:</span> ArrayImpl<span class="symbol">&lt;T&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，在<code>Array&lt;T&gt;</code>中添加一个接口，其内部则调用<code>ArrayImpl</code>的实现。</p>
<p>如上，尽管使用了<code>struct</code>，但是我们还并没有实现值语义，如果拷贝一个<code>struct</code>，新的<code>struct</code>依然指向相同的<code>ArrayImpl</code>，而我们又没法自定义<code>struct</code>的赋值操作，所以也没法拷贝。不过，我们可以从另一个角度去解决这个问题，我们可以思考一下，真正需要在什么时候进行拷贝的操作呢，答案就是做修改操作时，俗称的<code>COW</code>，既只有当进行修改操作时，才进行真正的拷贝。</p>
<p>比如，实现<code>append</code>方法来对<code>ArrayImpl</code>的拷贝添加一个元素（假设<code>ArrayImpl</code>已经实现了<code>copy</code>方法）：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">mutating <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(value: T)</span></span> &#123;</div><div class="line">    impl = impl.<span class="built_in">copy</span>()</div><div class="line">    impl.<span class="built_in">append</span>(value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，就实现了<code>Array</code>的值语义，尽管<code>a``b</code>赋值后依然指向相同的数据，但是只要修改其中的一个，就会进行拷贝操作，以保持数据的独立性。</p>
<p>如上的<code>append</code>方法，虽然实现了功能，但是效率太差，如：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span>: [Int] = []</div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">1000</span> &#123;</div><div class="line">    <span class="selector-tag">a</span>.append(i)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在每一次进行迭代时，指向的数据都会进行拷贝的操作，然后立即销毁之前的存储内存，那么我们如何处理这种情况呢？</p>
<h2 id="isKnownUniquelyReferenced"><a href="#isKnownUniquelyReferenced" class="headerlink" title="isKnownUniquelyReferenced"></a>isKnownUniquelyReferenced</h2><hr>
<p>该<code>API</code>返回一个布尔值，表明某个对象是否只有一个单独的强引用指向它。</p>
<p>有了这个<code>API</code>，我们就可以修改一下<code>append</code>方法，只在必要的时候进行拷贝：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">mutating <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(_ value: T)</span></span> &#123;</div><div class="line">    <span class="comment">// isKnownUniquelyReferenced并不是线程安全的哦</span></div><div class="line">    <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;impl) &#123;</div><div class="line">        impl = impl.<span class="built_in">copy</span>()</div><div class="line">    &#125;</div><div class="line">    impl.<span class="built_in">append</span>(obj: value)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="ArrayImpl"><a href="#ArrayImpl" class="headerlink" title="ArrayImpl"></a>ArrayImpl</h2><hr>
<p>接下来，我们将开始实现<code>ArrayImpl</code>。数组包含3个属性：数据指针、数组中元素的个数，以及当前分配的内存可存放的总个数。数据指针和数组元素个数这两个值是必须的，不过我们应当预先分配一定量的空闲内存区域，以避免过多的<code>reallocation</code>操作。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">class ArrayImpl&lt;<span class="built_in">T</span>&gt; &#123;</div><div class="line">    <span class="built_in">var</span> spa<span class="symbol">ce:</span> <span class="built_in">Int</span></div><div class="line">    <span class="built_in">var</span> cou<span class="symbol">nt:</span> <span class="built_in">Int</span></div><div class="line">    <span class="built_in">var</span> p<span class="symbol">tr:</span> UnsafeMutablePointer&lt;<span class="built_in">T</span>&gt;！</div></pre></td></tr></table></figure>
<p>接下来，实现<code>init</code>方法，<code>init</code>方法获取两个参数，<code>count</code>、<code>ptr</code>，拷贝指针的内容到新的对象。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">init(coun<span class="variable">t:</span> Int = <span class="number">0</span>, <span class="keyword">ptr</span>: UnsafeMutablePointer<span class="symbol">&lt;T&gt;</span>? = nil) &#123;</div><div class="line">    self.<span class="built_in">count</span> = <span class="built_in">count</span></div><div class="line">    self.space = <span class="built_in">count</span></div><div class="line">    </div><div class="line">    self.<span class="keyword">ptr</span> = UnsafeMutablePointer<span class="symbol">&lt;T&gt;</span>.allocate(capacity: <span class="built_in">count</span>)</div><div class="line">    </div><div class="line">    guard <span class="keyword">let</span> <span class="keyword">ptr</span> = <span class="keyword">ptr</span> <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    self.<span class="keyword">ptr</span>.initialize(from: <span class="keyword">ptr</span>, coun<span class="variable">t:</span> <span class="built_in">count</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，实现<code>append</code>方法，首先检查是否需要重新分配内存，如果没有多余的空间，则需要一块新的内存：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(obj: T)</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> space == <span class="built_in">count</span> &#123;</div></pre></td></tr></table></figure>
<p>首次分配内存时，分配容量初始为<code>space</code>的2倍，且最小容量设置为16.</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">let</span> newSpace = <span class="built_in">max</span>(<span class="built_in">space</span> * <span class="number">2</span>, <span class="number">16</span>)</div><div class="line"><span class="built_in">let</span> newPtr = UnsafeMutablePointer&lt;T&gt;.allocate(capacity: newSpace)</div></pre></td></tr></table></figure>
<p>接着将数据从原位置拷贝到新的指针所在的内存。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">newPtr.moveInitialize(<span class="keyword">from</span>: ptr, <span class="built_in">count</span>: <span class="built_in">count</span>)</div></pre></td></tr></table></figure>
<p>拷贝完成之后，就可以释放原来的内存了：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ptr</span>.deallocate(capacity: <span class="built_in">count</span>)</div><div class="line"><span class="keyword">ptr</span> = newPtr</div><div class="line">space = newSpace</div></pre></td></tr></table></figure>
<p>现在，已经有足够的空间来存放新的元素，我们将其拷贝到当前所有元素中最后一个元素后面内存区域并将<code>count</code>自增1：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">ptr</span> + <span class="built_in">count</span>).initialize(<span class="keyword">to</span>: obj)</div><div class="line"><span class="built_in">count</span> += <span class="number">1</span></div></pre></td></tr></table></figure>
<p><code>remove</code>操作也很简单，因为不需要重新分配内存。首先，清理待移除元素所在的内存：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(at index: Int)</span> &#123;</span></div><div class="line">    (<span class="built_in">ptr</span> + index).deinitialize()</div></pre></td></tr></table></figure>
<p><code>moveInitialize</code>方法可以使所有剩余的元素移动到指定的内存区域：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">ptr</span> + <span class="built_in">index</span>).moveInitialize(from: <span class="keyword">ptr</span> + <span class="built_in">index</span> + <span class="number">1</span>, coun<span class="variable">t:</span> <span class="built_in">count</span> - <span class="built_in">index</span> - <span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>然后将<code>count</code>减一来表明已经移除一个元素:</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">count</span> -= <span class="number">1</span></div></pre></td></tr></table></figure>
<p>当然，我们也需要实现<code>copy</code>方法，以实现必要的拷贝操作（真正执行拷贝操作是在<code>init</code>方法中）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">func <span class="keyword">copy</span>() -&gt; ArrayImpl<span class="symbol">&lt;T&gt;</span> &#123;</div><div class="line">    <span class="keyword">return</span> ArrayImpl<span class="symbol">&lt;T&gt;</span>(coun<span class="variable">t:</span> <span class="built_in">count</span>, <span class="keyword">ptr</span>: <span class="keyword">ptr</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，别忘了释放内存，我们可以在<code>deinit</code>中进行内存的释放操作：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">deinit</span> &#123;</div><div class="line">    ptr<span class="selector-class">.deinitialize</span>(<span class="attribute">count</span>: count)</div><div class="line">    <span class="selector-tag">ptr</span><span class="selector-class">.deallocate</span>(<span class="attribute">capacity</span>: space)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，<code>ArrayImpl</code>基本方法已经完成，接下来就是实现<code>Array</code>的<code>struct</code>的接口方法，其主要是调用<code>ArrayImpl</code>的实现。</p>
<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><hr>
<p>接下来，实现<code>Array</code>的一些接口方法，由于比较简单，直接上代码，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">ensureUnique</span><span class="params">()</span></span> &#123;</div><div class="line">    <span class="keyword">if</span> !isKnownUniquelyReferenced(&amp;impl) &#123;</div><div class="line">        impl = impl.copy()</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">append</span><span class="params">(<span class="number">_</span> value: T)</span></span> &#123;</div><div class="line">    ensureUnique()</div><div class="line">    impl.append(obj: value)</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="keyword">mutating</span> <span class="function"><span class="keyword">func</span> <span class="title">remove</span><span class="params">(at index: Int)</span></span> &#123;</div><div class="line">    ensureUnique()</div><div class="line">    impl.remove(at: index)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后，我们还要加上两个功能，下标访问以及<code>for...in</code>迭代，下标可以通过实现<code>subscript(index: Int)</code>方法，<code>for...in</code>迭代可以通过实现<code>Collection</code>协议的方法，具体如下：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">    <span class="selector-tag">var</span> count: Int &#123;</div><div class="line">    return impl<span class="selector-class">.count</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="function"><span class="title">subscript</span><span class="params">(index: Int)</span></span> -&gt; T &#123;</div><div class="line">    get &#123;</div><div class="line">        return impl<span class="selector-class">.ptr</span>[index]</div><div class="line">    &#125;</div><div class="line">    mutating set &#123;</div><div class="line">        ensureUnique()</div><div class="line">        impl<span class="selector-class">.ptr</span>[index] = newValue</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="selector-tag">var</span> description: String &#123;</div><div class="line">    <span class="selector-tag">var</span> str = <span class="string">""</span></div><div class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> self &#123;</div><div class="line">        <span class="keyword">if</span> !str<span class="selector-class">.isEmpty</span> &#123;</div><div class="line">            str += <span class="string">", "</span></div><div class="line">        &#125;</div><div class="line">        str += String(describing: value)</div><div class="line">    &#125;</div><div class="line">    return <span class="string">"(\(impl.ptr): "</span> + str + <span class="string">")"</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line">typealias Index = Int</div><div class="line">    </div><div class="line"><span class="selector-tag">var</span> startIndex: Index &#123;</div><div class="line">    return <span class="number">0</span></div><div class="line">&#125;</div><div class="line">    </div><div class="line"><span class="selector-tag">var</span> endIndex: Index &#123;</div><div class="line">    return count</div><div class="line">&#125;</div><div class="line">    </div><div class="line">func index(after <span class="selector-tag">i</span>: Int) -&gt; Int &#123;</div><div class="line">    return <span class="selector-tag">i</span> + <span class="number">1</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="源代码及测试代码"><a href="#源代码及测试代码" class="headerlink" title="源代码及测试代码"></a>源代码及测试代码</h2><hr>
<p>所有实现已上传<code>Github</code>：<a href="https://gist.github.com/zhongwuzw/2b194c9fb2e4aaaca04cedb79bf207f1" target="_blank" rel="external">https://gist.github.com/zhongwuzw/2b194c9fb2e4aaaca04cedb79bf207f1</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<p><a href="https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2015-04-17-lets-build-swiftarray.html</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;当我们从&lt;code&gt;Obj-C&lt;/code&gt;转到&lt;code&gt;Swift&lt;/code&gt;时，会发现&lt;code&gt;Swift&lt;/code&gt;提供的数据结构大量使用值语义，如&lt;code&gt;Array&lt;/code&gt;、&lt;code&gt;Dictionary&lt;/code&gt;等，今天，我们将实现&lt;code&gt;Array&lt;/code&gt;的基本功能，来理解值语义以及写时复制。&lt;/p&gt;
&lt;h2 id=&quot;值和引用语义&quot;&gt;&lt;a href=&quot;#值和引用语义&quot; class=&quot;headerlink&quot; title=&quot;值和引用语义&quot;&gt;&lt;/a&gt;值和引用语义&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;在实现之前，我们来简单讨论一下值语义和引用语义的区别。当我们使用&lt;code&gt;Obj-C&lt;/code&gt;及大多数其他面向对象语言开发时，经常会使用对象指针或引用，而这就是常说的引用语义，我们可以赋值一个对象实例的引用给一个变量：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyClass *a = ...;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;接着，可以将该变量赋值给另一个变量：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MyClass *b = a;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;此时，&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;将指向同一个对象，如果指向的对象是可变的，当我们修改对象的内容时，两者对其都可见。&lt;/p&gt;
&lt;p&gt;值语义相对比较简单，我们使用的如&lt;code&gt;int&lt;/code&gt;、&lt;code&gt;struct&lt;/code&gt;等都是值语义，声明为值语义的变量，其直接指向真正的值，而不是值的指针。所以当我们进行赋值时，将得到值的拷贝，如：&lt;/p&gt;
&lt;figure class=&quot;highlight mipsasm&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;int a = &lt;span class=&quot;number&quot;&gt;42&lt;/span&gt;&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;int &lt;span class=&quot;keyword&quot;&gt;b &lt;/span&gt;= a&lt;span class=&quot;comment&quot;&gt;;&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;b++;&lt;/span&gt;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此时，&lt;code&gt;b&lt;/code&gt;的值为&lt;code&gt;43&lt;/code&gt;，而&lt;code&gt;a&lt;/code&gt;依然为&lt;code&gt;42&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;Swift&lt;/code&gt;中，&lt;code&gt;class&lt;/code&gt;类型仍然是引用语义，&lt;code&gt;struct&lt;/code&gt;则为值语义，所以，如果对&lt;code&gt;class&lt;/code&gt;类型进行赋值时，将得到一个指向同一个实例的引用，对实例对象内容的修改将对所有的引用可见；使用&lt;code&gt;struct&lt;/code&gt;时，则不会，每个变量之间都是独立的。&lt;/p&gt;
&lt;p&gt;对于使用过&lt;code&gt;Obj-C&lt;/code&gt;开发过的人来说，转到&lt;code&gt;Swift&lt;/code&gt;使用其提供的数组和字典时，可能会不习惯，因为&lt;code&gt;Swift&lt;/code&gt;中两者已经变成了值语义，如：&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt; = [&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;]&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt; = &lt;span class=&quot;selector-tag&quot;&gt;a&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;selector-tag&quot;&gt;b&lt;/span&gt;.append(&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;)&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于大多数语言，如上代码的结果一般都是&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;都指向同一个数组&lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;。而在&lt;code&gt;Swift&lt;/code&gt;中，&lt;code&gt;a&lt;/code&gt;指向&lt;code&gt;[1, 2, 3]&lt;/code&gt;，&lt;code&gt;b&lt;/code&gt;则指向&lt;code&gt;[1, 2, 3, 4]&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;实现值语义&quot;&gt;&lt;a href=&quot;#实现值语义&quot; class=&quot;headerlink&quot; title=&quot;实现值语义&quot;&gt;&lt;/a&gt;实现值语义&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;如果对象包含固定数量的数据，那么实现就比较简单：我们直接将数据放到&lt;code&gt;struct&lt;/code&gt;中即可。比如想要一个2D &lt;code&gt;Point&lt;/code&gt;类型且满足值语义，可以创建一个&lt;code&gt;struct&lt;/code&gt;包含&lt;code&gt;x``y&lt;/code&gt;的值：&lt;/p&gt;
&lt;figure class=&quot;highlight excel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;struct Point &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;x:&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;symbol&quot;&gt;y:&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;Int&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://zhongwuzw.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>RxSwift之sentMessage、methodInvoked失效问题解决</title>
    <link href="https://zhongwuzw.github.io/2017/07/27/RxSwift%E4%B9%8BsentMessage%E3%80%81methodInvoked%E5%A4%B1%E6%95%88%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://zhongwuzw.github.io/2017/07/27/RxSwift之sentMessage、methodInvoked失效问题解决/</id>
    <published>2017-07-27T09:32:08.000Z</published>
    <updated>2018-11-23T13:22:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="RxSwift的sentMessage、methodInvoked方法"><a href="#RxSwift的sentMessage、methodInvoked方法" class="headerlink" title="RxSwift的sentMessage、methodInvoked方法"></a>RxSwift的<code>sentMessage</code>、<code>methodInvoked</code>方法</h2><hr>
<p><a href="https://github.com/ReactiveX/RxSwift" target="_blank" rel="external">RxSwift</a>是<a href="https://github.com/Reactive-Extensions/Rx.NET" target="_blank" rel="external">Rx</a>的<code>Swift</code>版本，用来实现函数式、响应式编程。</p>
<p>具体<code>RxSwift</code>的很多用法不做介绍，接下来，只讨论<code>sentMessage</code>、<code>methodInvoked</code>这两个方法，其作用是返回一个<code>Observable&lt;[Any]</code>，可以作为观察者监控<code>NSObject</code>子类的某个<code>selector</code>，当执行该<code>selector</code>时，将在执行前、后分别执行注册了该<code>selector</code>的<code>sentMessage</code>、<code>methodInvoked</code>方法。</p>
<h2 id="sentMessage、methodInvoked实现原理"><a href="#sentMessage、methodInvoked实现原理" class="headerlink" title="sentMessage、methodInvoked实现原理"></a><code>sentMessage</code>、<code>methodInvoked</code>实现原理</h2><hr>
<p><code>sentMessage</code>、<code>methodInvoked</code>只针对某个实例起作用，其实现首先借鉴了<code>KVO</code>的实现方法，通过创建监听的对象的子类，然后重写方法的实现来实现。<code>sentMessage</code>、<code>methodInvoked</code>实现分两个版本，基础版、优化版。基础版通过<code>Swizzle</code> <code>forwardInvocation:</code>、<code>respondsToSelector:</code>、<code>methodSignatureForSelector:</code>等函数，将所有需要观察的<code>selector</code>调用时进入<code>forwardInvocation:</code>流程，从而进行拦截，以实现通知；优化版则在基础版之上通过<code>Type Encoding</code>来做一个缓存优化，避免每次调用都进入转发的过程。</p>
<a id="more"></a>
<h2 id="sentMessage、methodInvoked遇到的问题"><a href="#sentMessage、methodInvoked遇到的问题" class="headerlink" title="sentMessage、methodInvoked遇到的问题"></a><code>sentMessage</code>、<code>methodInvoked</code>遇到的问题</h2><hr>
<p>在使用<code>sentMessage</code>、<code>methodInvoked</code>方法时，发现一个问题，当观察<code>iOS</code> <code>Framework</code>提供的方法时，可以正常运行，但是当观察自己创建的类（<code>NSObject</code>的子类）的实例的方法时，却始终无法运行，查看整个运行机制，<code>Class</code>、<code>IMP</code>都被正确替换，但是调用方法时，却始终截取不到，这下才意识到，难道是被编译器优化掉了？导致没有走<code>Objective-C</code>的动态派发？<br>遂翻看<code>Apple</code>的<a href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/" target="_blank" rel="external">Using Swift with Cocoa and Objective-C</a>，有一段话是这么说的：</p>
<blockquote>
<p>“When Swift APIs are imported by the Objective-C runtime, there are no guarantees of dynamic dispatch for properties, methods, subscripts, or initializers. The Swift compiler may still devirtualize or inline member access to optimize the performance of your code, bypassing the Objective-C runtime.</p>
<p>You can use the dynamic modifier to require that access to members be dynamically dispatched through the Objective-C runtime. Requiring dynamic dispatch is rarely necessary. However, it is necessary when using APIs like key–value observing or the method_exchangeImplementations function in the Objective-C runtime, which dynamically replace the implementation of a method at runtime. If the Swift compiler inlined the implementation of the method or devirtualized access to it, the new implementation would not be used.”</p>
</blockquote>
<p>大概意思是当在<code>Swift</code>中使用<code>Objective-C</code>中定义的方法时，编译器不保证动态派发，会对其做优化来提高性能，导致的结果是，会使<code>KVO</code>、<code>Swizzling</code>等失效，要解决该问题，可以使用<code>dynamic</code>修饰符，使得方法强制进行<code>Objective-C</code>的动态派发。</p>
<p>这样，问题就解决了，原来是编译器优化搞的鬼。<br><a href="https://stackoverflow.com/questions/39708434/observable-for-selector-rxswift/45340883#45340883" target="_blank" rel="external">stackoverflow</a>上也有人提这个问题，我也进行了回答。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;RxSwift的sentMessage、methodInvoked方法&quot;&gt;&lt;a href=&quot;#RxSwift的sentMessage、methodInvoked方法&quot; class=&quot;headerlink&quot; title=&quot;RxSwift的sentMessage、methodInvoked方法&quot;&gt;&lt;/a&gt;RxSwift的&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;方法&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxSwift&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;RxSwift&lt;/a&gt;是&lt;a href=&quot;https://github.com/Reactive-Extensions/Rx.NET&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Rx&lt;/a&gt;的&lt;code&gt;Swift&lt;/code&gt;版本，用来实现函数式、响应式编程。&lt;/p&gt;
&lt;p&gt;具体&lt;code&gt;RxSwift&lt;/code&gt;的很多用法不做介绍，接下来，只讨论&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;这两个方法，其作用是返回一个&lt;code&gt;Observable&amp;lt;[Any]&lt;/code&gt;，可以作为观察者监控&lt;code&gt;NSObject&lt;/code&gt;子类的某个&lt;code&gt;selector&lt;/code&gt;，当执行该&lt;code&gt;selector&lt;/code&gt;时，将在执行前、后分别执行注册了该&lt;code&gt;selector&lt;/code&gt;的&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;方法。&lt;/p&gt;
&lt;h2 id=&quot;sentMessage、methodInvoked实现原理&quot;&gt;&lt;a href=&quot;#sentMessage、methodInvoked实现原理&quot; class=&quot;headerlink&quot; title=&quot;sentMessage、methodInvoked实现原理&quot;&gt;&lt;/a&gt;&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;实现原理&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;只针对某个实例起作用，其实现首先借鉴了&lt;code&gt;KVO&lt;/code&gt;的实现方法，通过创建监听的对象的子类，然后重写方法的实现来实现。&lt;code&gt;sentMessage&lt;/code&gt;、&lt;code&gt;methodInvoked&lt;/code&gt;实现分两个版本，基础版、优化版。基础版通过&lt;code&gt;Swizzle&lt;/code&gt; &lt;code&gt;forwardInvocation:&lt;/code&gt;、&lt;code&gt;respondsToSelector:&lt;/code&gt;、&lt;code&gt;methodSignatureForSelector:&lt;/code&gt;等函数，将所有需要观察的&lt;code&gt;selector&lt;/code&gt;调用时进入&lt;code&gt;forwardInvocation:&lt;/code&gt;流程，从而进行拦截，以实现通知；优化版则在基础版之上通过&lt;code&gt;Type Encoding&lt;/code&gt;来做一个缓存优化，避免每次调用都进入转发的过程。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发-项目" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://zhongwuzw.github.io/tags/Swift/"/>
    
      <category term="RxSwift" scheme="https://zhongwuzw.github.io/tags/RxSwift/"/>
    
      <category term="Runtime" scheme="https://zhongwuzw.github.io/tags/Runtime/"/>
    
  </entry>
  
  <entry>
    <title>Swift3之Weak引用</title>
    <link href="https://zhongwuzw.github.io/2017/06/17/Swift%E4%B9%8BWeak%E5%BC%95%E7%94%A8/"/>
    <id>https://zhongwuzw.github.io/2017/06/17/Swift之Weak引用/</id>
    <published>2017-06-17T13:33:22.000Z</published>
    <updated>2017-06-19T16:06:19.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>由于不同的<code>Swift</code>版本引用计数实现会有不同，该文讨论的引用计数原理都基于<code>Swift3</code></p>
</blockquote>
<h2 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h2><hr>
<p>做<code>iOS</code>开发时经常会遇到循环引用，如果处理不当会导致内存泄露，我们通常会使用<code>weak reference</code>弱引用来解决该问题，因为弱引用不会<code>retain</code>对象，当对象引用计数变为0时，弱引用指针将会被赋<code>nil</code>。</p>
<h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><hr>
<p>通常如果实现弱引用，可以让每一个对象维护所有指向该对象的一个弱引用列表，当一个弱引用指向一个对象时，该引用被添加进列表，当弱引用重新赋值或生命期结束，则将其从列表中移除，当一个对象<code>dealloced</code>后，列表中的所有引用会被赋<code>nil</code>。在多线程环境中，需要对获得弱引用和释放对象的操作进行同步，以避免竞态条件，既当一个线程在释放最后一个强引用对象的同时，另一个线程正尝试加载该对象的弱引用。</p>
<p><code>Objective-C</code>实现的过程为，每一个弱引用是一个指向目标对象的指针，编译器会使用<code>helper</code>函数，来避免直接读写指针，确保读取弱引用对象时不会返回正在被释放的对象指针。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><hr>
<p>接下来，我们将创建几个方法来观察弱引用的过程。<br>首先我们想要能够<code>dump</code>出一个对象的内存，如下方法将获取一块内存，将其分成指针大小的块，再将其内容转成16进制，以便于观察：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">// Swift <span class="keyword">version</span>: Swift3</div><div class="line"></div><div class="line">func contents(<span class="keyword">ptr</span>: UnsafeRawPointer, _ length: Int) -&gt; String &#123;</div><div class="line">    <span class="keyword">let</span> wordPtr = <span class="keyword">ptr</span>.assumingMemoryBound(<span class="keyword">to</span>: UInt.self)</div><div class="line">    </div><div class="line">    <span class="keyword">let</span> words = length / MemoryLayout<span class="symbol">&lt;UInt&gt;</span>.size</div><div class="line">    <span class="keyword">let</span> wordChars = MemoryLayout<span class="symbol">&lt;UInt&gt;</span>.size * <span class="number">2</span></div><div class="line">    </div><div class="line">    <span class="keyword">let</span> <span class="keyword">buffer</span> = UnsafeBufferPointer<span class="symbol">&lt;UInt&gt;</span>(<span class="keyword">star</span><span class="variable">t:</span> wordPtr, coun<span class="variable">t:</span> words)</div><div class="line">    <span class="keyword">let</span> wordStrings = <span class="keyword">buffer</span>.<span class="keyword">map</span>(&#123; word -&gt; String in</div><div class="line">        var wordString = String(word, radix: <span class="number">16</span>)</div><div class="line">        <span class="keyword">while</span> wordString.characters.<span class="built_in">count</span> &lt; wordChars &#123;</div><div class="line">            wordString = <span class="string">"0"</span> + wordString</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> wordString</div><div class="line">    &#125;)</div><div class="line">    <span class="keyword">return</span> wordStrings.joined(separator: <span class="string">" "</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>接下来，我们将创建一个<code>dumper</code>函数来打印一个对象实例的内容，参数为一个对象实例，函数返回一个闭包。在函数内部，会创建一个<code>UnsafeRawPointer</code>指针来指向对象，这样能确保不会进行引用计数的操作，且当对象被释放后，我们仍可以<code>dump</code>出指针所指向内存的内容。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Swift version: Swift3</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">func</span> <span class="title">dumperFunc</span><span class="params">(<span class="number">_</span> obj: AnyObject)</span></span> -&gt; ((<span class="type">Void</span>) -&gt; <span class="type">String</span>) &#123;</div><div class="line">    <span class="keyword">let</span> objString = <span class="type">String</span>(describing: obj)</div><div class="line">    <span class="keyword">let</span> ptr = <span class="built_in">unsafeBitCast</span>(obj, to: <span class="type">UnsafeRawPointer</span>.<span class="keyword">self</span>)</div><div class="line">    <span class="keyword">let</span> length = class_getInstanceSize(type(of: obj))</div><div class="line">    <span class="keyword">return</span> &#123;</div><div class="line">        <span class="keyword">let</span> bytes = contents(ptr: ptr, length)</div><div class="line">        <span class="keyword">return</span> <span class="string">"<span class="subst">\(objString)</span> <span class="subst">\(ptr)</span>: <span class="subst">\(bytes)</span>"</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如下有一个类，它有一个弱引用的属性<code>target</code>，同时，创建两个<code>dummy</code>属性，当<code>dump</code>内存内容时可以更清晰的识别：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakReferer</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> dummy1 = <span class="number">0x1234321012343210</span></div><div class="line">        <span class="keyword">weak</span> <span class="keyword">var</span> target: <span class="type">WeakTarget</span>?</div><div class="line">        <span class="keyword">var</span> dummy2: <span class="type">UInt</span> = <span class="number">0xabcdefabcdefabcd</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>接下来，创建一个该对象的实例，并<code>dump</code>出内存的内容：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">let referer = WeakReferer()</div><div class="line">let refererDump = dumperFunc(<span class="name">referer</span>)</div><div class="line">print(<span class="name">refererDump</span>())</div></pre></td></tr></table></figure>
<p>结果为：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x000060000004eb50: <span class="number">000000010</span>ebb0c50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>我们可以看到，<code>dummy1</code>位于第4块，<code>dummy2</code>位于第6块，弱引用位于他们中间，正如我们期待的，其内容为0.</p>
<p>现在我们给它赋一个值看看，我将通过一个<code>do</code>块来控制<code>target</code>的生命周期：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">// 因为<span class="keyword">target</span>是NSObject对象，所以需要改一下WeakReferer的<span class="keyword">target</span>属性的类型</div><div class="line"></div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">        let <span class="keyword">target</span> = NSObject()</div><div class="line">        referer.<span class="keyword">target</span> = <span class="keyword">target</span></div><div class="line">        <span class="built_in">print</span>(<span class="keyword">target</span>)</div><div class="line">        <span class="built_in">print</span>(refererDump())</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;NSObject: <span class="number">0</span>x7fda<span class="number">6a21c6a0</span>&gt;</div><div class="line">    WeakReferer <span class="number">0</span>x00007fda6a000ad0: <span class="number">00000001050</span>a44a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">00007</span>fda<span class="number">6a21c6a0</span> abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>正如我们所看到的，<code>target</code>对象的指针直接存放在弱引用中。接下来，我们在<code>do</code>块结束之后再打印一下看看<code>target</code>释放后的情况：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">print(<span class="name">refererDump</span>())</div></pre></td></tr></table></figure>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">WeakReferer <span class="number">0</span>x00007ffe<span class="number">32300060</span>: <span class="number">000000010</span>cfb44a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>被赋值为了<code>nil</code>.</p>
<p>接下来，我们再测试一下将<code>target</code>赋值为一个纯<code>Swift</code>对象，看是不是和<code>Objective-C</code>的<code>NSObject</code>一样，如下为纯<code>Swift``target</code>：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>再试一下，看看结果怎样：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">let referer = WeakReferer()</div><div class="line">let refererDump = dumperFunc(referer)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(refererDump()</span></span>)</div><div class="line">do &#123;</div><div class="line">  let target = WeakTarget()</div><div class="line">  referer<span class="selector-class">.target</span> = target</div><div class="line">  print(refererDump())</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(refererDump()</span></span>)</div></pre></td></tr></table></figure>
<p><code>target</code>开始为<code>nil</code>，然后赋给它一个值：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">000060800002</span>a9c2 abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>接下来，当<code>target</code>离开作用域，我们看看弱引用是否被赋<code>nil</code>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">000060800002</span>a9c2 abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>咦，怎么没被赋<code>nil</code>，难道是<code>target</code>没有被释放，产生了内存泄露？我们给<code>target</code>对象加上析构函数看看：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</div><div class="line">        <span class="keyword">deinit</span> &#123; <span class="built_in">print</span>(<span class="string">"WeakTarget deinit"</span>) &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>运行之前的代码，看看结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">000060800002</span>a9c2 abcdefabcdefabcd</div><div class="line">WeakTarget deinit</div><div class="line">SwiftLearn<span class="selector-class">.WeakReferer</span> <span class="number">0</span>x00006000002423a0: <span class="number">000000010538</span>bc50 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">000060800002</span>a9c2 abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>析构函数被调用了，但是弱引用并没有被赋<code>nil</code>，这跟我们印象中的<code>weak</code>运行过程有出入，我们接着访问一下该值，看是否会产生<code>crash</code>：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">let referer = WeakReferer()</div><div class="line">    let refererDump = dumperFunc(referer)</div><div class="line">    <span class="built_in">print</span>(refererDump())</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        let <span class="keyword">target</span> = WeakTarget()</div><div class="line">        referer.<span class="keyword">target</span> = <span class="keyword">target</span></div><div class="line">        <span class="built_in">print</span>(refererDump())</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">print</span>(refererDump())</div><div class="line">    <span class="built_in">print</span>(referer.<span class="keyword">target</span>)</div></pre></td></tr></table></figure>
<figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">WeakReferer <span class="number">0x00007ff7aa20d</span>060: <span class="number">00000001047</span>a04a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div><div class="line">WeakReferer <span class="number">0x00007ff7aa20d</span>060: <span class="number">00000001047</span>a04a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">00007f</span>f7aa2157f0 abcdefabcdefabcd</div><div class="line">WeakTarget deinit</div><div class="line">WeakReferer <span class="number">0x00007ff7aa20d</span>060: <span class="number">00000001047</span>a04a0 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">00007f</span>f7aa2157f0 abcdefabcdefabcd</div><div class="line"><span class="literal">nil</span></div></pre></td></tr></table></figure>
<p>并没有产生<code>crash</code>，打印结果为<code>nil</code>。<br>让我们再仔细的分析一下，首先我们先给<code>WeakTarget</code>对象加上一个<code>dummy</code>属性，<code>dump</code>的时候能更方便的查看内存内容：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeakTarget</span> </span>&#123;</div><div class="line">        <span class="keyword">var</span> dummy = <span class="number">0x0123456789abcdef</span></div><div class="line"></div><div class="line">        <span class="keyword">deinit</span> &#123;</div><div class="line">            <span class="built_in">print</span>(<span class="string">"Weak target deinit"</span>)</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，我们将使用新的代码执行相同的过程并<code>dump</code>出每一步的对象内容：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">let referer = WeakReferer()</div><div class="line">let refererDump = dumperFunc(referer)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(refererDump()</span></span>)</div><div class="line">let targetDump: (Void) -&gt; String</div><div class="line">do &#123;</div><div class="line">  let target = WeakTarget()</div><div class="line">  targetDump = dumperFunc(target)</div><div class="line">  print(targetDump())</div><div class="line">  </div><div class="line">  referer<span class="selector-class">.target</span> = target</div><div class="line">  </div><div class="line">  print(refererDump())</div><div class="line">  print(targetDump())</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(refererDump()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(targetDump()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(referer.target)</span></span></div><div class="line"><span class="function"><span class="title">print</span><span class="params">(refererDump()</span></span>)</div><div class="line"><span class="function"><span class="title">print</span><span class="params">(targetDump()</span></span>)</div></pre></td></tr></table></figure>
<p>我们一个一个看一下输出的内容。一开始，<code>target</code>属性为<code>nil</code>:</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakReferer <span class="number">0</span>x0000<span class="number">608000243450</span>: <span class="number">000000010</span>cec4c58 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>给<code>target</code>属性设置一个对象实例，<code>target</code>对象实例的内容为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000357e0</span>: <span class="number">000000010</span>cec4d48 <span class="number">0000000200000004</span> <span class="number">0123456789</span>abcdef</div></pre></td></tr></table></figure>
<p>将对象实例赋给<code>target</code>属性，我们能够看到<code>weak</code>属性已经被赋值了，赋的值为<code>target</code>对象地址+2字节，既对于<code>weak</code>指针，它并不直接指向对象的地址，而是指向对象的<code>side table</code>（下文会讲到<code>side table</code>的概念），<code>unowned``strong</code>引用会直接指向对象：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakReferer <span class="number">0</span>x0000<span class="number">608000243450</span>: <span class="number">000000010</span>cec4c58 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">00006080000357</span>e2 abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p><code>target</code>对象的内容块中有一个字段自增了2：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000357e0</span>: <span class="number">000000010</span>cec4d48 <span class="number">0000000400000004</span> <span class="number">0123456789</span>abcdef</div></pre></td></tr></table></figure>
<p><code>target</code>被析构：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">WeakTarget deinit</span></div></pre></td></tr></table></figure>
<p>我们看到引用的对象依然保持着<code>target</code>的指针：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakReferer <span class="number">0</span>x0000<span class="number">608000243450</span>: <span class="number">000000010</span>cec4c58 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">00006080000357</span>e2 abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p>看上去好像<code>target</code>依然还存活着，我们看到<code>target</code>对象的有一个字段减了2：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000357e0</span>: <span class="number">000000010</span>cec4d48 <span class="number">0000000200000002</span> <span class="number">0123456789</span>abcdef</div></pre></td></tr></table></figure>
<p>访问一下<code>target</code>属性，此时会产生<code>nil</code>，尽管内容中的指针并没有被赋<code>nil</code>:</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="literal">nil</span></div></pre></td></tr></table></figure>
<p>我们再打印一下<code>referer</code>对象的内容，发现访问完<code>target</code>属性后，<code>target</code>字段被修改了，赋为了<code>nil</code>：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakReferer <span class="number">0</span>x0000<span class="number">608000243450</span>: <span class="number">000000010</span>cec4c58 <span class="number">0000000200000004</span> <span class="number">1234321012343210</span> <span class="number">0000000000000000</span> abcdefabcdefabcd</div></pre></td></tr></table></figure>
<p><code>target</code>对象现在完全被清除了：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000357e0</span>: <span class="number">000000010</span>cec3370 <span class="number">0000000200000008</span> <span class="number">000000010</span>cebe200</div></pre></td></tr></table></figure>
<p>从上面的运行过程，我们发现某些字段会被增/减，我们进行一些测试，来看一下有没有规律：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = <span class="type">WeakTarget</span>()</div><div class="line"><span class="keyword">let</span> targetDump = dumperFunc(target)</div><div class="line"><span class="keyword">do</span> &#123;</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> a = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> b = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> <span class="built_in">c</span> = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> d = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">weak</span> <span class="keyword">var</span> e = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  </div><div class="line">  <span class="keyword">var</span> f = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">var</span> g = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">var</span> h = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">var</span> i = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">var</span> j = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">  <span class="keyword">var</span> k = target</div><div class="line">  <span class="built_in">print</span>(targetDump())</div><div class="line">&#125;</div><div class="line"><span class="built_in">print</span>(targetDump())</div></pre></td></tr></table></figure>
<p>打印结果为：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000200000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000400000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000600000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000800000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>a<span class="number">00000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c<span class="number">00000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c<span class="number">00000008</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c0000000c <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c<span class="number">00000010</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c<span class="number">00000014</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c<span class="number">00000018</span> <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000</span>c0000001c <span class="number">0123456789</span>abcdef</div><div class="line">SwiftLearn.WeakTarget <span class="number">0</span>x000060<span class="number">80000395a0</span>: <span class="number">000000010</span>e8aad40 <span class="number">0000000200000004</span> <span class="number">0123456789</span>abcdef</div><div class="line">WeakTarget deinit</div></pre></td></tr></table></figure>
<p>从结果，我们能够看到，对于每一个<code>weak</code>引用，第2个块中的第一个数会自增2；而每一个<code>strong</code>引用，第二个数会自增4.</p>
<p>总结一下：</p>
<ul>
<li>弱指针看起来就是普通的指针。</li>
<li>当一个弱引用对象的<code>deinit</code>执行后，对象并没有被释放，且弱引用指针也没有被赋<code>nil</code>。</li>
<li>当弱引用执行完<code>deinit</code>后，访问弱引用对象，则对象指针会被赋<code>nil</code>,且目标对象被释放。</li>
<li>弱引用对象对于每一个弱引用会包含一个引用计数（<code>unowned</code>计数和<code>weak</code>计数为同一个），且与强引用计数分开统计。 </li>
</ul>
<h2 id="Swift代码"><a href="#Swift代码" class="headerlink" title="Swift代码"></a>Swift代码</h2><hr>
<p>接下来，我们看一下<code>Swift</code>实现的源代码。<br><code>Swift</code>标准库表示一个在堆上的对象的结构体为：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/// The Swift3 heap-object header.</span></div><div class="line"><span class="keyword">struct</span> HeapObject &#123;</div><div class="line">  <span class="comment">/// This is always a valid pointer to a metadata object.</span></div><div class="line">  HeapMetadata <span class="keyword">const</span> *metadata;</div><div class="line"></div><div class="line">  SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS;</div><div class="line">  <span class="comment">// <span class="doctag">FIXME:</span> allocate two words of metadata on 32-bit platforms</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></div><div class="line">  HeapObject() = <span class="built_in">default</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Initialize a HeapObject header as appropriate for a newly-allocated object.</span></div><div class="line">  <span class="keyword">constexpr</span> HeapObject(HeapMetadata <span class="keyword">const</span> *newMetadata) </div><div class="line">    : metadata(newMetadata)</div><div class="line">    , refCounts(InlineRefCounts::Initialized)</div><div class="line">  &#123; &#125;</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><code>Swift</code>的<code>metadata</code>字段等同于<code>Objective-C</code>的<code>isa</code>字段，事实上，他们是兼容的。接着，使用了一个宏来定义字段，该字段用来管理引用计数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">///Swift默认为InlineRefCounts，当有弱引用指向该对象时，InlineRefCounts会变为SideTableRefCounts</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SWIFT_HEAPOBJECT_NON_OBJC_MEMBERS       \</span></div><div class="line">  InlineRefCounts refCounts</div></pre></td></tr></table></figure>
<p>Swift增加引用计数的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Increment the reference count.</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">uint32_t</span> inc = <span class="number">1</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> oldbits = refCounts.load(SWIFT_MEMORY_ORDER_CONSUME);</div><div class="line">  RefCountBits newbits;</div><div class="line">  <span class="keyword">do</span> &#123;</div><div class="line">    newbits = oldbits;</div><div class="line">    <span class="keyword">bool</span> fast = newbits.incrementStrongExtraRefCount(inc);</div><div class="line">    <span class="keyword">if</span> (!fast)</div><div class="line">      <span class="keyword">return</span> incrementSlow(oldbits, inc);</div><div class="line">  &#125; <span class="keyword">while</span> (!refCounts.compare_exchange_weak(oldbits, newbits,</div><div class="line">                                            <span class="built_in">std</span>::memory_order_relaxed));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于引用计数的管理有两种类型<code>InlineRefCounts</code>、<code>SideTableRefCounts</code>，当对象只包含<code>strong</code>或<code>unowned</code>引用时，使用<code>InlineRefCounts</code>进行计数管理，如果对象拥有了<code>weak</code>引用，则会使用<code>SideTableRefCounts</code>来管理计数。所以如上增加引用计数的函数，会考虑两种情况，<code>fast</code>对应<code>InlineRefCounts</code>，<code>slow</code>对应<br><code>SideTableRefCounts</code>，为了避免竞态条件，使用了<code>compare_exchange_weak</code>来进行赋值。</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class">HeapObject </span>&#123;</div><div class="line">  isa</div><div class="line">  <span class="class">InlineRefCounts </span>&#123;</div><div class="line">    atomic<span class="params">&lt;InlineRefCountBits&gt;</span> &#123;</div><div class="line">      strong RC + unowned RC + flags</div><div class="line">      OR</div><div class="line">      HeapObjectSideTableEntry*</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class">HeapObjectSideTableEntry </span>&#123;</div><div class="line">  <span class="class">SideTableRefCounts </span>&#123;</div><div class="line">    object pointer</div><div class="line">    atomic<span class="params">&lt;SideTableRefCountBits&gt;</span> &#123;</div><div class="line">      strong RC + unowned RC + weak RC + flags</div><div class="line">    &#125;</div><div class="line">  &#125;   </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来，看一下<code>weak</code>引用自减计数的函数操作过程，函数内调用<code>decrementWeakShouldCleanUp</code>来进行位数的操作，其返回一个<code>bool</code>值，既当<code>weak</code>、<code>strong</code>、<code>unowned</code>计数都变为0时，<code>bool</code>值返回<code>true</code>，说明可以收回内存了，既调用<code>delete</code>释放内存。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">decrementWeak</span><span class="params">()</span> </span>&#123;</div><div class="line">  <span class="comment">// <span class="doctag">FIXME:</span> assertions</span></div><div class="line">  <span class="comment">// <span class="doctag">FIXME:</span> optimize barriers</span></div><div class="line">  <span class="keyword">bool</span> cleanup = refCounts.decrementWeakShouldCleanUp();</div><div class="line">  <span class="keyword">if</span> (!cleanup)</div><div class="line">    <span class="keyword">return</span>;</div><div class="line"></div><div class="line">  <span class="comment">// Weak ref count is now zero. Delete the side table entry.</span></div><div class="line">  <span class="comment">// FREED -&gt; DEAD</span></div><div class="line">  assert(refCounts.getUnownedCount() == <span class="number">0</span>);</div><div class="line">  <span class="keyword">delete</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，我们应该就比较清楚了，即使<code>strong</code>或<code>unowned</code>的计数为0，如果还存在<code>weak</code>弱引用，<br>那么对象也不会被释放。</p>
<p>接下来，我们可以看一下加载弱引用的过程，<code>Swift</code>通过<code>HeapObject *swift::swift_weakTakeStrong(WeakReference *ref)</code>函数来实现，该函数通过间接调用，最终调用<code>nativeTakeStrongFromBits</code>函数，该函数内部首先会调用<code>getNativeOrNull</code>方法，该方法会从对象的<code>side table</code>中查询对象的计数，当没有<code>strong</code>引用时，说明该对象已经处于<code>DEINITING</code>状态，函数会返回<code>nullptr</code>，否则将调用<code>tryRetain</code>函数来尝试<code>strong</code>对象。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function">HeapObject *<span class="title">nativeTakeStrongFromBits</span><span class="params">(WeakReferenceBits bits)</span> </span>&#123;</div><div class="line">  <span class="keyword">auto</span> side = bits.getNativeOrNull();</div><div class="line">  <span class="keyword">if</span> (side) &#123;</div><div class="line">    side-&gt;decrementWeak();</div><div class="line">    <span class="keyword">return</span> side-&gt;tryRetain();</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当对象实例的<code>deinit()</code>方法被调用时，内部会调用<code>swift_deallocObject</code>函数，而它会通过调用<code>canBeFreedNow</code>函数来判断是否需要释放内存，既满足没有<code>side table</code>，<code>unowned</code>引用为1，<code>strong</code>引用计数为0。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">bool </span>canBeFreedNow() const &#123;</div><div class="line">auto <span class="keyword">bits </span>= refCounts.load(<span class="keyword">SWIFT_MEMORY_ORDER_CONSUME);</span></div><div class="line">return (!<span class="keyword">bits.hasSideTable() </span>&amp;&amp;</div><div class="line">          <span class="keyword">bits.getIsDeiniting() </span>&amp;&amp;</div><div class="line">          <span class="keyword">bits.getStrongExtraRefCount() </span>== <span class="number">0</span> &amp;&amp;</div><div class="line">          <span class="keyword">bits.getUnownedRefCount() </span>== <span class="number">1</span>)<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>综上，如果还存在<code>weak</code><br>弱引用，那么肯定还有<code>side table</code>表，即使没有<code>strong</code>引用，也不会被释放。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ol>
<li>弱引用指向对象实例的<code>side table</code>地址。</li>
<li>与<code>Objective-C</code>管理引用计数的方式不同，<code>Swift</code>的弱引用计数与<code>strong</code>计数一起管理。</li>
<li><code>Swift</code>针对对象的析构和对象的释放进行了解耦，一个对象被析构后，会释放它的外部资源，但是有可能不会释放对象本身的内存。</li>
<li>当<code>Swift</code>对象的<code>strong</code>引用计数变为0但是<code>weak</code>计数大于0时，对象会被析构但是不会被释放内存。</li>
<li>当加载一个弱引用时，运行时会检查<code>target</code>的状态<br>，如果<code>target</code>已经是僵尸对象，那么会赋空<code>weak</code>引用，<code>weak</code>计数减一，并返回<code>nil</code>,这个过程是安全的，当<code>weak</code>引用计数变为0时，僵尸对象内存将被释放。</li>
</ol>
<p>最后总结一下<code>Swift</code>与<code>Objective-C</code>的区别：</p>
<ul>
<li><code>Swift</code>不需要维护<code>weak</code>列表，这可以简化代码和提升性能。</li>
<li>对于<code>Swift</code>的<code>weak</code>引用，实例对象会在<code>strong</code>引用计数变为0时，内存依然保留，直到所有的<code>weak</code>引用离开作用域。不过这个影响是很小的，因为虽然对象分配的内存依然保留，但是它所有的外部资源（如<code>Array</code>、<code>Dictionary</code>属性）会在<code>strong</code>引用计数变为0时被释放。</li>
<li>由于<code>Swift</code>的<code>weak</code>创建后，对象的引用计数管理会从<code>InlineRefCounts</code>替换为<code>SideTableRefCounts</code>，这也会带来一定的开销，所以如果可以，尽量使用<code>unowned</code>,<code>unowned</code>有点类似于<code>Objective-C</code>的<code>__unsafe_unretained</code>，如果<code>unowned</code>指向僵尸对象后再访问，会产生未定义行为。</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a href="https://github.com/apple/swift/blob/7913e9821b814956d243e4e03cfe9ddc0e325bc2/stdlib/public/SwiftShims/HeapObject.h" target="_blank" rel="external">https://github.com/apple/swift/blob/7913e9821b814956d243e4e03cfe9ddc0e325bc2/stdlib/public/SwiftShims/HeapObject.h</a></li>
<li><a href="https://github.com/apple/swift/blob/860252fab41392b7de3218e58f7542cb1dc1ce16/stdlib/public/runtime/WeakReference.h" target="_blank" rel="external">https://github.com/apple/swift/blob/860252fab41392b7de3218e58f7542cb1dc1ce16/stdlib/public/runtime/WeakReference.h</a></li>
<li><a href="https://github.com/apple/swift/blob/b7d78853112c1279fc7bc5b85853779040f13703/stdlib/public/SwiftShims/RefCount.h" target="_blank" rel="external">https://github.com/apple/swift/blob/b7d78853112c1279fc7bc5b85853779040f13703/stdlib/public/SwiftShims/RefCount.h</a></li>
<li><a href="https://github.com/apple/swift/blob/b7d78853112c1279fc7bc5b85853779040f13703/stdlib/public/SwiftShims/RefCount.h#L123-#L187" target="_blank" rel="external">Swift对象生命周期状态机</a></li>
<li><a href="https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html" target="_blank" rel="external">https://www.mikeash.com/pyblog/friday-qa-2015-12-11-swift-weak-references.html</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;由于不同的&lt;code&gt;Swift&lt;/code&gt;版本引用计数实现会有不同，该文讨论的引用计数原理都基于&lt;code&gt;Swift3&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;弱引用&quot;&gt;&lt;a href=&quot;#弱引用&quot; class=&quot;headerlink&quot; title=&quot;弱引用&quot;&gt;&lt;/a&gt;弱引用&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;做&lt;code&gt;iOS&lt;/code&gt;开发时经常会遇到循环引用，如果处理不当会导致内存泄露，我们通常会使用&lt;code&gt;weak reference&lt;/code&gt;弱引用来解决该问题，因为弱引用不会&lt;code&gt;retain&lt;/code&gt;对象，当对象引用计数变为0时，弱引用指针将会被赋&lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;实现过程&quot;&gt;&lt;a href=&quot;#实现过程&quot; class=&quot;headerlink&quot; title=&quot;实现过程&quot;&gt;&lt;/a&gt;实现过程&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;通常如果实现弱引用，可以让每一个对象维护所有指向该对象的一个弱引用列表，当一个弱引用指向一个对象时，该引用被添加进列表，当弱引用重新赋值或生命期结束，则将其从列表中移除，当一个对象&lt;code&gt;dealloced&lt;/code&gt;后，列表中的所有引用会被赋&lt;code&gt;nil&lt;/code&gt;。在多线程环境中，需要对获得弱引用和释放对象的操作进行同步，以避免竞态条件，既当一个线程在释放最后一个强引用对象的同时，另一个线程正尝试加载该对象的弱引用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Objective-C&lt;/code&gt;实现的过程为，每一个弱引用是一个指向目标对象的指针，编译器会使用&lt;code&gt;helper&lt;/code&gt;函数，来避免直接读写指针，确保读取弱引用对象时不会返回正在被释放的对象指针。&lt;/p&gt;
&lt;h2 id=&quot;实战&quot;&gt;&lt;a href=&quot;#实战&quot; class=&quot;headerlink&quot; title=&quot;实战&quot;&gt;&lt;/a&gt;实战&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;接下来，我们将创建几个方法来观察弱引用的过程。&lt;br&gt;首先我们想要能够&lt;code&gt;dump&lt;/code&gt;出一个对象的内存，如下方法将获取一块内存，将其分成指针大小的块，再将其内容转成16进制，以便于观察：&lt;/p&gt;
&lt;figure class=&quot;highlight vim&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;13&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;14&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;15&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;16&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;17&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;18&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;// Swift &lt;span class=&quot;keyword&quot;&gt;version&lt;/span&gt;: Swift3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;func contents(&lt;span class=&quot;keyword&quot;&gt;ptr&lt;/span&gt;: UnsafeRawPointer, _ length: Int) -&amp;gt; String &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wordPtr = &lt;span class=&quot;keyword&quot;&gt;ptr&lt;/span&gt;.assumingMemoryBound(&lt;span class=&quot;keyword&quot;&gt;to&lt;/span&gt;: UInt.self)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; words = length / MemoryLayout&lt;span class=&quot;symbol&quot;&gt;&amp;lt;UInt&amp;gt;&lt;/span&gt;.size&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wordChars = MemoryLayout&lt;span class=&quot;symbol&quot;&gt;&amp;lt;UInt&amp;gt;&lt;/span&gt;.size * &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;buffer&lt;/span&gt; = UnsafeBufferPointer&lt;span class=&quot;symbol&quot;&gt;&amp;lt;UInt&amp;gt;&lt;/span&gt;(&lt;span class=&quot;keyword&quot;&gt;star&lt;/span&gt;&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt; wordPtr, coun&lt;span class=&quot;variable&quot;&gt;t:&lt;/span&gt; words)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; wordStrings = &lt;span class=&quot;keyword&quot;&gt;buffer&lt;/span&gt;.&lt;span class=&quot;keyword&quot;&gt;map&lt;/span&gt;(&amp;#123; word -&amp;gt; String in&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        var wordString = String(word, radix: &lt;span class=&quot;number&quot;&gt;16&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; wordString.characters.&lt;span class=&quot;built_in&quot;&gt;count&lt;/span&gt; &amp;lt; wordChars &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;            wordString = &lt;span class=&quot;string&quot;&gt;&quot;0&quot;&lt;/span&gt; + wordString&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wordString&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wordStrings.joined(separator: &lt;span class=&quot;string&quot;&gt;&quot; &quot;&lt;/span&gt;)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Swift" scheme="https://zhongwuzw.github.io/tags/Swift/"/>
    
  </entry>
  
  <entry>
    <title>GCD队列管理之YYDispatchQueuePool</title>
    <link href="https://zhongwuzw.github.io/2017/06/05/GCD%E9%98%9F%E5%88%97%E7%AE%A1%E7%90%86%E4%B9%8BYYDispatchQueuePool/"/>
    <id>https://zhongwuzw.github.io/2017/06/05/GCD队列管理之YYDispatchQueuePool/</id>
    <published>2017-06-05T13:33:44.000Z</published>
    <updated>2018-11-23T13:38:17.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><code>iOS</code>中，我们经常使用<code>GCD</code>来进行并发操作，我们并不需要关心线程的管理，<code>Dispatch Queue</code>会自动帮我们处理线程的创建和释放，在极大的简化并发操作的同时，某些情况下，<code>Dispatch Queue</code>的滥用可能会导致应用挂起，如向并发队列中添加阻塞的<code>Block</code>，阻塞的<code>Block</code>会导致系统创建更多的线程来处理任务，而<code>GCD</code>线程池的最大线程数为64个，所以一旦达到最大值，应用将挂起。<br>接下来，我将列出一些解决方案，来更好的使用<code>Dispatch Queue</code>。</p>
<h2 id="YYDispatchQueue"><a href="#YYDispatchQueue" class="headerlink" title="YYDispatchQueue"></a>YYDispatchQueue</h2><hr>
<p><a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">YYDispatchQueue</a>的主要思想是使用串行队列来替换并发队列，可以为指定的<code>NSQualityOfService</code>创建一个队列池，由<code>YYDispatchQueuePool</code>对象来进行管理，每一种<code>NSQualityOfService</code>最多可以创建32个串行队列，通过<code>- (dispatch_queue_t)queue;</code>方法来获取可用队列，其采用<code>Round Robin</code>轮询算法。</p>
<p><img src="http://oc54pu02q.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-05%20%E4%B8%8B%E5%8D%8811.28.12.png" alt=""></p>
<p>除了可以创建队列池来管理并发外，还可以通过<code>C</code>的全局函数（<code>dispatch_queue_t YYDispatchQueueGetForQOS(NSQualityOfService qos)</code>）来获取特定的<code>NSQualityOfService</code>串行队列，队列由全局的队列池来管理，每一种<code>NSQualityOfService</code>的串行队列数与核数相同，这样可以尽可能的减少线程之间的上下文切换。</p>
<a id="more"></a>
<p><code>YYDispatchQueuePool</code>对象使用<code>YYDispatchContext</code> <code>struct</code>来管理队列池，代码目前还存在内存泄露的问题，因为<code>struct</code>是在堆上分配的内存，最后使用<code>YYDispatchContextRelease</code>释放<code>context</code>时只释放了结构体成员的内存空间，而没有释放结构体自己申请的空间，解决方法如下注释，加上<code>free(context)</code>即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</div><div class="line">    <span class="keyword">void</span> **queues;</div><div class="line">    <span class="keyword">uint32_t</span> queueCount;</div><div class="line">    <span class="keyword">int32_t</span> counter;</div><div class="line">&#125; YYDispatchContext;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">YYDispatchContextRelease</span><span class="params">(YYDispatchContext *context)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!context) <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">if</span> (context-&gt;queues) &#123;</div><div class="line">        <span class="keyword">for</span> (NSUInteger i = <span class="number">0</span>; i &lt; context-&gt;queueCount; i++) &#123;</div><div class="line">            <span class="keyword">void</span> *queuePointer = context-&gt;queues[i];</div><div class="line">            <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span> = (<span class="number">__b</span>ridge_transfer <span class="keyword">dispatch_queue_t</span>)(queuePointer);</div><div class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = dispatch_queue_get_label(<span class="built_in">queue</span>);</div><div class="line">            <span class="keyword">if</span> (name) <span class="built_in">strlen</span>(name); <span class="comment">// avoid compiler warning</span></div><div class="line">            <span class="built_in">queue</span> = nil;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">free</span>(context-&gt;queues);</div><div class="line">        context-&gt;queues = <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (context-&gt;name) <span class="built_in">free</span>((<span class="keyword">void</span> *)context-&gt;name);</div><div class="line">    <span class="comment">//内存泄露，需添加  free(context);</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h2><hr>
<p>使用<code>NSOperationQueue</code>，设置<code>maxConcurrentOperationCount</code>来控制并发量。</p>
<h2 id="Dispatch-Semaphores"><a href="#Dispatch-Semaphores" class="headerlink" title="Dispatch Semaphores"></a>Dispatch Semaphores</h2><hr>
<p>使用<code>Dispatch Queue</code>时，可以用信号量来控制并发的数量，<code>GCD</code>提供信号量的支持，<code>dispatch_semaphore_t</code>用来表示信号量。在往队列添加任务之前，可以使用<code>dispatch_semaphore_wait</code>来获取信号量，成功获取后即可往队列中添加任务，当任务完成时，使用<code>dispatch_semaphore_signal</code>来释放信号量。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 示例代码需要封装一下，不要直接在主线程或次级线程中直接调用dispatch_semaphore_wait，可能会引发UI挂起</span></div><div class="line"><span class="params">...</span></div><div class="line">dispatch_semaphore_t concurrencyLimitingSemaphore = dispatch_semaphore_create(limit);</div><div class="line"><span class="params">...</span></div><div class="line"></div><div class="line">dispatch_semaphore_wait(concurrencyLimitingSemaphore, DISPATCH_TIME_FOREVER);</div><div class="line">dispatch_async(someConcurrentQueue, ^&#123;</div><div class="line">    <span class="comment">/* work goes here */</span></div><div class="line">    dispatch_semaphore_signal(concurrencyLimitingSemaphore);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a href="https://stackoverflow.com/questions/7213845/number-of-threads-created-by-gcd" target="_blank" rel="external">https://stackoverflow.com/questions/7213845/number-of-threads-created-by-gcd</a></li>
<li><a href="https://github.com/ibireme/YYDispatchQueuePool" target="_blank" rel="external">https://github.com/ibireme/YYDispatchQueuePool</a></li>
<li><a href="https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24" target="_blank" rel="external">https://developer.apple.com/library/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationQueues/OperationQueues.html#//apple_ref/doc/uid/TP40008091-CH102-SW24</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;iOS&lt;/code&gt;中，我们经常使用&lt;code&gt;GCD&lt;/code&gt;来进行并发操作，我们并不需要关心线程的管理，&lt;code&gt;Dispatch Queue&lt;/code&gt;会自动帮我们处理线程的创建和释放，在极大的简化并发操作的同时，某些情况下，&lt;code&gt;Dispatch Queue&lt;/code&gt;的滥用可能会导致应用挂起，如向并发队列中添加阻塞的&lt;code&gt;Block&lt;/code&gt;，阻塞的&lt;code&gt;Block&lt;/code&gt;会导致系统创建更多的线程来处理任务，而&lt;code&gt;GCD&lt;/code&gt;线程池的最大线程数为64个，所以一旦达到最大值，应用将挂起。&lt;br&gt;接下来，我将列出一些解决方案，来更好的使用&lt;code&gt;Dispatch Queue&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;YYDispatchQueue&quot;&gt;&lt;a href=&quot;#YYDispatchQueue&quot; class=&quot;headerlink&quot; title=&quot;YYDispatchQueue&quot;&gt;&lt;/a&gt;YYDispatchQueue&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ibireme/YYDispatchQueuePool&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;YYDispatchQueue&lt;/a&gt;的主要思想是使用串行队列来替换并发队列，可以为指定的&lt;code&gt;NSQualityOfService&lt;/code&gt;创建一个队列池，由&lt;code&gt;YYDispatchQueuePool&lt;/code&gt;对象来进行管理，每一种&lt;code&gt;NSQualityOfService&lt;/code&gt;最多可以创建32个串行队列，通过&lt;code&gt;- (dispatch_queue_t)queue;&lt;/code&gt;方法来获取可用队列，其采用&lt;code&gt;Round Robin&lt;/code&gt;轮询算法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oc54pu02q.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202017-06-05%20%E4%B8%8B%E5%8D%8811.28.12.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;除了可以创建队列池来管理并发外，还可以通过&lt;code&gt;C&lt;/code&gt;的全局函数（&lt;code&gt;dispatch_queue_t YYDispatchQueueGetForQOS(NSQualityOfService qos)&lt;/code&gt;）来获取特定的&lt;code&gt;NSQualityOfService&lt;/code&gt;串行队列，队列由全局的队列池来管理，每一种&lt;code&gt;NSQualityOfService&lt;/code&gt;的串行队列数与核数相同，这样可以尽可能的减少线程之间的上下文切换。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发-项目" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://zhongwuzw.github.io/tags/Objective-C/"/>
    
      <category term="GCD" scheme="https://zhongwuzw.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>iOS浏览器-WebBrowser</title>
    <link href="https://zhongwuzw.github.io/2017/05/26/iOS%E6%B5%8F%E8%A7%88%E5%99%A8-WebBrowser/"/>
    <id>https://zhongwuzw.github.io/2017/05/26/iOS浏览器-WebBrowser/</id>
    <published>2017-05-26T10:22:11.000Z</published>
    <updated>2017-10-30T07:35:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>一款用于网页浏览的APP（Web Browser For iOS)。<a href="https://github.com/zhongwuzw/WebBrowser" target="_blank" rel="external">Github地址</a></p>
<h2 id="Features-功能"><a href="#Features-功能" class="headerlink" title="Features - 功能"></a>Features - 功能</h2><ol>
<li>多Tab页浏览(multi-tab browsing)</li>
<li>冷启动恢复浏览记录，包括当前页及前进后退页面(session restore, includes current page and backforward list)</li>
<li>书签、历史记录管理(bookmark、history manage)</li>
<li>页内查找(find in page)</li>
<li>点击标题栏进行页面访问或搜索(tap the title bar to  input url for surf or key to search)</li>
<li>自动监控剪切板<code>URL</code>，可在新窗口中打开</li>
</ol>
<h2 id="Usage-用法"><a href="#Usage-用法" class="headerlink" title="Usage - 用法"></a>Usage - 用法</h2><ol>
<li><code>clone</code> or download zip file.</li>
<li>Run command <code>carthage update --platform iOS</code></li>
<li>Just run WebBrowser.xcodeproj</li>
</ol>
<h2 id="Requirements-依赖"><a href="#Requirements-依赖" class="headerlink" title="Requirements - 依赖"></a>Requirements - 依赖</h2><ul>
<li>iOS 8.0 or higher</li>
<li>ARC</li>
<li><a href="https://github.com/Carthage/Carthage" target="_blank" rel="external">Carthage</a></li>
</ul>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h4 id="1-Home-Page-主页-："><a href="#1-Home-Page-主页-：" class="headerlink" title="1. Home Page (主页)："></a>1. Home Page (主页)：</h4><p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/home_scroll.gif" alt="home page"><br></p>


<h4 id="2-Multi-tab-多窗口-："><a href="#2-Multi-tab-多窗口-：" class="headerlink" title="2. Multi-tab (多窗口)："></a>2. Multi-tab (多窗口)：</h4><p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/home_tab_switch.gif" alt="tab"><br></p>

<p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/tab_manage.gif" alt="tab"><br></p>

<p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/multi_window_switch.gif" alt="tab"><br></p>

<h4 id="3-Search-搜索-："><a href="#3-Search-搜索-：" class="headerlink" title="3. Search (搜索)："></a>3. Search (搜索)：</h4><p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/home_search.gif" alt="search"><br></p>

<h4 id="4-No-Image-Mode-无图模式"><a href="#4-No-Image-Mode-无图模式" class="headerlink" title="4. No Image Mode (无图模式)"></a>4. No Image Mode (无图模式)</h4><p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/no-image-mode.gif" alt="no image mode"><br></p>

<h4 id="5-History-历史"><a href="#5-History-历史" class="headerlink" title="5. History (历史)"></a>5. History (历史)</h4><ol>
<li>Long Press to select options. (长按记录可弹出选项按钮)</li>
<li>Tap to open history in current window.(点击记录会在当前窗口打开历史页面)<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/history.gif" alt="history"><br></p>

</li>
</ol>
<h4 id="6-Favorite-收藏"><a href="#6-Favorite-收藏" class="headerlink" title="6. Favorite (收藏)"></a>6. Favorite (收藏)</h4><h5 id="In-non-editing-mode-在非编辑模式下操作"><a href="#In-non-editing-mode-在非编辑模式下操作" class="headerlink" title="In non-editing mode (在非编辑模式下操作)"></a>In non-editing mode (在非编辑模式下操作)</h5><ol>
<li><p>Long press on directory to edit directory name in non-editing mode.(长按目录来编辑目录名字)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_edit_long_section.gif" alt="favorite"><br></p>
</li>
<li><p>Long press on bookmark item to edit bookmark’s url, name, directory in non-editing mode.(长按书签项来编辑书签的地址、名字、以及所在目录)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_long_edit_item.gif" alt="favorite"><br></p>

</li>
</ol>
<h5 id="In-editing-mode-在编辑模式下"><a href="#In-editing-mode-在编辑模式下" class="headerlink" title="In editing mode (在编辑模式下)"></a>In editing mode (在编辑模式下)</h5><ol>
<li><p>reorder, delete directory in editing mode.(删除、排序目录)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_edit_section.gif" alt="favorite"><br></p>
</li>
<li><p>click “新文件夹” button to add new directory in editing mode.(点击”新文件夹”按钮来创建新的目录)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_add_section.gif" alt="favorite"><br></p>
</li>
<li><p>reorder, delete bookmark in editing mode.(删除、排序书签)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_edit_item.gif" alt="favorite"><br></p>
</li>
<li><p>add new bookmark.(添加新书签)</p>
<p align="center"><br><img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/bookmark_add.gif" alt="favorite"><br></p>

</li>
</ol>
<h4 id="7-find-in-page-页内查找"><a href="#7-find-in-page-页内查找" class="headerlink" title="7. find in page (页内查找)"></a>7. find in page (页内查找)</h4><p align="center"><br>  <img src="https://raw.githubusercontent.com/zhongwuzw/WebBrowser/master/images/findinpage.gif" alt="find in page"><br></p>

<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>The MIT License (MIT)</p>
<p>Copyright (c) 2017 Zhong Wu</p>
<p>Permission is hereby granted, free of charge, to any person obtaining a copy<br>of this software and associated documentation files (the “Software”), to deal<br>in the Software without restriction, including without limitation the rights<br>to use, copy, modify, merge, publish, distribute, sublicense, and/or sell<br>copies of the Software, and to permit persons to whom the Software is<br>furnished to do so, subject to the following conditions:</p>
<p>The above copyright notice and this permission notice shall be included in all<br>copies or substantial portions of the Software.</p>
<p>THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR<br>IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,<br>FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE<br>AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER<br>LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,<br>OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE<br>SOFTWARE.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一款用于网页浏览的APP（Web Browser For iOS)。&lt;a href=&quot;https://github.com/zhongwuzw/WebBrowser&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Github地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 i
    
    </summary>
    
      <category term="iOS开发-项目" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://zhongwuzw.github.io/tags/Objective-C/"/>
    
      <category term="浏览器" scheme="https://zhongwuzw.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    
      <category term="项目开发" scheme="https://zhongwuzw.github.io/tags/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>WWDC-Session406-优化App启动时间</title>
    <link href="https://zhongwuzw.github.io/2017/05/01/WWDC-Session406-%E4%BC%98%E5%8C%96App%E5%90%AF%E5%8A%A8%E6%97%B6%E9%97%B4/"/>
    <id>https://zhongwuzw.github.io/2017/05/01/WWDC-Session406-优化App启动时间/</id>
    <published>2017-05-01T15:46:05.000Z</published>
    <updated>2018-12-31T08:15:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><hr>
<h3 id="Mach-O"><a href="#Mach-O" class="headerlink" title="Mach-O"></a>Mach-O</h3><h4 id="Mach-O相关术语"><a href="#Mach-O相关术语" class="headerlink" title="Mach-O相关术语"></a>Mach-O相关术语</h4><p><code>Mach-O</code>为<code>Mach Object</code>文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核存储的文件格式。它包括多种文件类型：</p>
<ul>
<li><code>Executable</code>(可执行文件)：App的主二进制文件</li>
<li><code>Dylib</code>：动态库（如<code>DSO</code>、<code>DLL</code>)</li>
<li><code>Bundle</code>：不能被链接的动态库，只能通过<code>dlopen()</code>，用于<code>Mac OS</code>。</li>
</ul>
<p><code>Image</code>：可以是可执行文件、动态库或者<code>bundle</code>。<br><code>Framework</code>：动态库，包含资源和头文件。</p>
<h4 id="Mach-O-Image文件"><a href="#Mach-O-Image文件" class="headerlink" title="Mach-O Image文件"></a>Mach-O Image文件</h4><p>一个<code>Mach-O</code>文件由3部分组成：<code>Header</code>、<code>Load commands</code>、<code>Raw segment data</code>。<code>Header</code>描述了文件的目标架构等信息，如x86-64,PPC；<code>Load commands</code>列出了文件的逻辑结构及文件在虚拟内存中的布局;<code>Raw segment data</code>包含了在<code>Load commands</code>中指出的<code>segment</code>(<code>段</code>)。在<code>Mach-O</code>文件中，我们把<code>Header</code>、<code>Load commands</code>放在了<code>__TEXT</code> <code>segment</code>(<code>段</code>)的开头，即第一个<code>segment</code>(<code>段</code>)的开头。每一个<code>段</code>由多个<code>page</code>(<code>页</code>)组成，<code>段</code>的大小为<code>页</code>大小的整数倍。如下图，<code>TEXT段</code>占3<code>页</code>，<code>DATA</code>、<code>LINKEDIT</code>分别占1<code>页</code>。<code>页</code>的大小取决于硬件，在<code>arm64</code>下，<code>页</code>大小为16K，其它则为4K。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_1.png" alt=""></p>
<p>我们还可以从<code>section</code>(节)的角度来理解<code>段</code>,编译器对<code>section</code>是透明的，<code>section</code>仅仅是一个<code>段</code>的子区间，它没有任何的大小约束，但是<code>section</code>之间不会产生重叠。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_2.png" alt=""></p>
<p>事实上，每一个二进制文件都包含<code>TEXT</code>、<code>DATA</code>、<code>LINKEDIT</code>这3个通用的<code>段</code>，<code>TEXT</code>位于文件的开始，它包括<code>Mach header</code>，机器指令，代码以及只读常量如C字符串，<code>DATA段</code>是可读写的，其包括所有的全局变量，静态变量等。<code>LINKEDIT</code>包含加载程序的<code>meta data</code>(元数据)，如符号，字符串，重定向表条目，供动态链接器使用。</p>
<a id="more"></a>
<h4 id="Mach-O-Universal-Files"><a href="#Mach-O-Universal-Files" class="headerlink" title="Mach-O Universal Files"></a>Mach-O Universal Files</h4><p>当我们在编译iOS应用时，会针对不同的设备架构编译出不同的Mach-O文件，如下图，产生64位（arm64）、32位（如armv7s)两种架构的<code>Mach-O</code>文件，之后将这两个文件合并成一个文件，这个文件就叫<code>Mach-O universal file</code>。该文件包含一个<code>Fat header</code>，包含所有架构的列表，且对应在文件中的偏移量。<code>header</code>占1<code>页</code>空间，下文，将会讲述为什么需要占1<code>页</code>空间，以及涉及到的虚拟内存的知识。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_3.png" alt=""></p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p>每一个进程都是一个逻辑地址空间，逻辑地址会被映射到<code>RAM</code>的物理页中，当然，这个映射并不是一对一的，逻辑地址不需要在一开始就映射到物理内存，多个逻辑地址也可以映射到相同的物理RAM。<br>如果逻辑地址没有映射到物理RAM，当访问该逻辑地址时，会产生缺页中断，这时，内核会暂停执行该线程，去处理缺页中断；当多个进程，不同的逻辑地址，被映射到相同的物理页时，这些进程就可以共享相同的bit（位），做到进程间共享。<br>还有一个特点是文件映射，通过mmap函数，可以不用将整个文件加载到RAM中，而把文件的片段映射到进程的内存地址中，所以，在访问未映射的地址时，内核也将产生缺页中断。<br>综上，我们可以总结出，动态库或<code>Image</code>的<code>TEXT段</code>可以被映射到多个进程中，其是懒加载的（即使用<code>mmap</code>），共享的。<code>DATA段</code>是可读写的，所以采用了写时复制（COW，Copy-On-Write）的策略，当有进程对<code>DATA</code>进行写时，才真正进行复制的操作，内核会拷贝被修改页到另一个物理RAM并将映射重定向该位置，这时，该进程就拥有了该<code>页</code>的拷贝，该拷贝页被称为<code>dirty page</code>，<code>dirty page</code>包含了进程的特定信息;内核可以重新生成的<code>page</code>称为<code>clean page</code>，当需要访问该页时，可以从磁盘重新读出，显然<code>dirty page</code>代价比<code>clean page</code>大。<br>接下来，将举一个例子来讲述一下Mach-O和虚拟内存之间的映射。如示例，有一个Mach-O文件，我们将其映射到内存中，而不是将其全部读入内存，如果全部读入内存，需占用8<code>页</code>，而使用映射，其中的<code>ZeroFill</code>将不需要占用空间，原因是大多数的全局变量初始化为0，所以可以对此进行优化，将所有为零的全局变量移到末尾，且不占用磁盘空间，当第一次访问ZeroFill<code>页</code>时，直接赋空，所以，其并不需要进行读操作。dyld一开始会读<code>Mach header</code>，由于其没有映射到物理页，内核将产生缺页中断，VM会读取文件的Mach-O文件的第一页到物理页中，并设置映射，这时，dyld就能开始读取<code>Mach header</code>，读取完<code>Mach header</code>后，<code>Mach header</code>会声称有一些信息保存在<code>LINKEDIT</code>中，需要读取，这时，dyld会跳到<code>Process 1</code>的空间底部，进行<code>LINKEDIT</code>的读取，此时，由于内存中没有，内核会进行和之前读取<code>Mach header</code>时一样的操作，产生缺页中断，读取到物理内存并完成映射，处理完<code>LINKEDIT</code>后，<code>LINKEDIT</code>会告诉dyld，其需要对<code>DATA页</code>进行<code>fix-up</code>（调整）以便让该动态库可运行，此时，内核又会进行之前的操作，不过这次有一些不同，因为该动态库会对<code>DATA</code>进行修改，所以，此时会进行写时复制的操作，该<code>页</code>将变为<code>dirty page</code>，此时，内存中就存在两<code>页clean page</code>和一<code>页dirty page</code>。<br>此时，如果又有<code>Process 2</code>加载相同的动态库，此时，在<code>Process 2</code>进程中，dyld也会进行相同的步骤。<br>首先，它会进行<code>Mach header</code>的读取，由于该<code>页</code>已经在RAM中了，所以内核只是简单的将其映射重定向到该<code>页</code>，不需要进行<code>IO</code>，<code>LINKEDIT</code>的读取也是如此，此时到了<code>DATA页</code>，内核会查询RAM中是否存在该<code>DATA页</code>，且是<code>clean page</code>，如果找到，则重用，否则，重新进行读取操作，在该例中，<code>DATA页</code>是<code>dirty page</code>，所以需要再申请一个新的物理<code>页</code>来进行映射，<code>Process 2</code>需修改<code>DATA页</code>，所以<code>DATA页</code>同样标识为<code>dirty page</code>。<br>最后，由于<code>LINKEDIT页</code>只有在dyld进行处理时需要，所以，一旦dyld完成处理，这些<code>LINKEDIT页</code>占用的空间就可以被收回。这样，这个例子，最终我们仅仅拥有2个<code>dirty page</code>，1个<code>clean</code>，共享的<code>page</code>（<code>LINKEDIT页</code>空间被收回）。</p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_4.png" alt=""></p>
<h3 id="exec-函数-main-被调用之前做了什么"><a href="#exec-函数-main-被调用之前做了什么" class="headerlink" title="exec()函数 - [main()被调用之前做了什么]"></a>exec()函数 - [main()被调用之前做了什么]</h3><p><code>exec</code>是一个系统调用，内核会清理地址空间，将需要运行的可执行文件映射到空间中，且是一个随机地址，接下来，从该地址到0x000000，将被标记为不可读、写和可执行，该区域的大小将不小于4KB（对于32位进程）或4GB（对于64位进程）。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_5.png" alt=""><br>现代程序中，我们经常会使用共享库，如Unix中so，所以，当内核完成进程的映射后，将会把dyld映射到另一个随机的地址，并让dyld来完成进程的启动。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_6.png" alt=""><br>此时，dyld运行在进程中，并负责加载依赖的所有动态库，准备好并运行。<br>在整个dyld处理的过程中，需要如下图所示的几步，首先，dyld加载所有依赖的动态库（通过读取主可执行文件的<code>header</code>来获得依赖库列表），在加载时，存在某个动态库依赖其他动态库的情况，这个过程是递归执行的。通常，进程会加载100到400个动态库，不过我们几乎不用考虑性能的问题，因为这些库很多都是系统库，内核已经提前加载缓存了。<br><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_7.png" alt=""><br>接下来是<code>rebasing</code>和<code>binding</code>，两者的区别为<code>rebasing</code>是当指针指向自己的<code>image</code>而做出调整（调整起来很简单，加一个offset就可以），<code>binding</code>是指针指向其他的<code>image</code>而做出调整。调整都是在<code>DATA页</code>中进行。<br>有人会问，为什么会需要进行调整呢，主要考虑的因素是安全，不能直接修改指令，所以当一个动态库需要调用其它的动态库时，需要在其中加一个间接层，在<code>DATA段</code>中来创建一个指针指向调用的地址，这就涉及到指针的调整，dyld就负责这些操作。<br>Objective-C的类结构指针、方法指针等，也都是通过<code>rebasing</code>或<code>binding</code>来进行调整，由于Objective-C是动态语言，我们可以通过字符串来创建一个类实例，所以<code>Objective-C Runtime</code>需要维护一个包括所有类名的映射。<br>使用过C++的开发者应该知道，C++存在Fragile基类的问题，Objective-C则没有这个问题，因为在加载时，dyld会动态调整所有实例变量的偏移。<br>处理完前面的操作，如果有C++，这个时候dyld会调用初始化器；如果有Objective-C，类别会被添加到方法列表中，且会调用<code>+load</code>方法，当然，我们已经不推荐使用它了，而是使用<code>+initialize</code>方法。<br>最终，我们才调用<code>main()</code>。</p>
<h2 id="将理论应用到实际"><a href="#将理论应用到实际" class="headerlink" title="将理论应用到实际"></a>将理论应用到实际</h2><hr>
<ul>
<li>通过设置环境变量<code>DYLD_PRINT_STATISTICS</code>，可以打印出dyld加载相关信息，包括每部分消耗的时间。</li>
<li>前面提到，app平均会有100到400个动态库，但是很多库，系统都已经加载了，但是，有些动态库是无法被系统提前加载的，就是我们内嵌在app中的动态库，所以，加载这些动态库时会带来一些消耗，想要解决这个问题，我们可以将多个动态库合并，可以使用使用静态库；还可以使用延迟加载，既通过<code>dlopen</code>，不过需要注意的是，<code>dlopen</code>会带来性能和正确性问题，因为它虽然做到了延迟，但是之后需要更多的操作。</li>
<li>减少Objective-C类对象和实例变量的数量，因为，如之前所说，数量太多，会增加<code>rebasing</code>或<code>binding</code>的时间。</li>
<li>减少C++虚函数的使用，因为虚函数会创建虚表，其需要在<code>DATA</code>中创建结构且需要进行调整。</li>
<li>使用Swift，Swift做了很多优化，避免了很多操作。</li>
<li>推荐用<code>+initialize</code>来替换<code>+load</code>。</li>
<li>不要在初始化器中起线程。</li>
<li><code>Xcode9</code>后，可以通过<code>Instruments</code>来跟踪静态初始化器的时间。</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<p><a href="https://github.com/kpwn/iOSRE/blob/master/wiki/Mach-O.md" target="_blank" rel="external">Mach-O</a><br><a href="https://developer.apple.com/videos/play/wwdc2016/406/?time=690" target="_blank" rel="external">Optimizing App Startup Time</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;理论&quot;&gt;&lt;a href=&quot;#理论&quot; class=&quot;headerlink&quot; title=&quot;理论&quot;&gt;&lt;/a&gt;理论&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;Mach-O&quot;&gt;&lt;a href=&quot;#Mach-O&quot; class=&quot;headerlink&quot; title=&quot;Mach-O&quot;&gt;&lt;/a&gt;Mach-O&lt;/h3&gt;&lt;h4 id=&quot;Mach-O相关术语&quot;&gt;&lt;a href=&quot;#Mach-O相关术语&quot; class=&quot;headerlink&quot; title=&quot;Mach-O相关术语&quot;&gt;&lt;/a&gt;Mach-O相关术语&lt;/h4&gt;&lt;p&gt;&lt;code&gt;Mach-O&lt;/code&gt;为&lt;code&gt;Mach Object&lt;/code&gt;文件格式的缩写，它是一种用于可执行文件，目标代码，动态库，内核存储的文件格式。它包括多种文件类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Executable&lt;/code&gt;(可执行文件)：App的主二进制文件&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Dylib&lt;/code&gt;：动态库（如&lt;code&gt;DSO&lt;/code&gt;、&lt;code&gt;DLL&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Bundle&lt;/code&gt;：不能被链接的动态库，只能通过&lt;code&gt;dlopen()&lt;/code&gt;，用于&lt;code&gt;Mac OS&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Image&lt;/code&gt;：可以是可执行文件、动态库或者&lt;code&gt;bundle&lt;/code&gt;。&lt;br&gt;&lt;code&gt;Framework&lt;/code&gt;：动态库，包含资源和头文件。&lt;/p&gt;
&lt;h4 id=&quot;Mach-O-Image文件&quot;&gt;&lt;a href=&quot;#Mach-O-Image文件&quot; class=&quot;headerlink&quot; title=&quot;Mach-O Image文件&quot;&gt;&lt;/a&gt;Mach-O Image文件&lt;/h4&gt;&lt;p&gt;一个&lt;code&gt;Mach-O&lt;/code&gt;文件由3部分组成：&lt;code&gt;Header&lt;/code&gt;、&lt;code&gt;Load commands&lt;/code&gt;、&lt;code&gt;Raw segment data&lt;/code&gt;。&lt;code&gt;Header&lt;/code&gt;描述了文件的目标架构等信息，如x86-64,PPC；&lt;code&gt;Load commands&lt;/code&gt;列出了文件的逻辑结构及文件在虚拟内存中的布局;&lt;code&gt;Raw segment data&lt;/code&gt;包含了在&lt;code&gt;Load commands&lt;/code&gt;中指出的&lt;code&gt;segment&lt;/code&gt;(&lt;code&gt;段&lt;/code&gt;)。在&lt;code&gt;Mach-O&lt;/code&gt;文件中，我们把&lt;code&gt;Header&lt;/code&gt;、&lt;code&gt;Load commands&lt;/code&gt;放在了&lt;code&gt;__TEXT&lt;/code&gt; &lt;code&gt;segment&lt;/code&gt;(&lt;code&gt;段&lt;/code&gt;)的开头，即第一个&lt;code&gt;segment&lt;/code&gt;(&lt;code&gt;段&lt;/code&gt;)的开头。每一个&lt;code&gt;段&lt;/code&gt;由多个&lt;code&gt;page&lt;/code&gt;(&lt;code&gt;页&lt;/code&gt;)组成，&lt;code&gt;段&lt;/code&gt;的大小为&lt;code&gt;页&lt;/code&gt;大小的整数倍。如下图，&lt;code&gt;TEXT段&lt;/code&gt;占3&lt;code&gt;页&lt;/code&gt;，&lt;code&gt;DATA&lt;/code&gt;、&lt;code&gt;LINKEDIT&lt;/code&gt;分别占1&lt;code&gt;页&lt;/code&gt;。&lt;code&gt;页&lt;/code&gt;的大小取决于硬件，在&lt;code&gt;arm64&lt;/code&gt;下，&lt;code&gt;页&lt;/code&gt;大小为16K，其它则为4K。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;我们还可以从&lt;code&gt;section&lt;/code&gt;(节)的角度来理解&lt;code&gt;段&lt;/code&gt;,编译器对&lt;code&gt;section&lt;/code&gt;是透明的，&lt;code&gt;section&lt;/code&gt;仅仅是一个&lt;code&gt;段&lt;/code&gt;的子区间，它没有任何的大小约束，但是&lt;code&gt;section&lt;/code&gt;之间不会产生重叠。&lt;br&gt;&lt;img src=&quot;https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/start_up_optimize_2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;事实上，每一个二进制文件都包含&lt;code&gt;TEXT&lt;/code&gt;、&lt;code&gt;DATA&lt;/code&gt;、&lt;code&gt;LINKEDIT&lt;/code&gt;这3个通用的&lt;code&gt;段&lt;/code&gt;，&lt;code&gt;TEXT&lt;/code&gt;位于文件的开始，它包括&lt;code&gt;Mach header&lt;/code&gt;，机器指令，代码以及只读常量如C字符串，&lt;code&gt;DATA段&lt;/code&gt;是可读写的，其包括所有的全局变量，静态变量等。&lt;code&gt;LINKEDIT&lt;/code&gt;包含加载程序的&lt;code&gt;meta data&lt;/code&gt;(元数据)，如符号，字符串，重定向表条目，供动态链接器使用。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发-项目" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="优化" scheme="https://zhongwuzw.github.io/tags/%E4%BC%98%E5%8C%96/"/>
    
      <category term="WWDC" scheme="https://zhongwuzw.github.io/tags/WWDC/"/>
    
  </entry>
  
  <entry>
    <title>服务器之从裸机到可用</title>
    <link href="https://zhongwuzw.github.io/2017/03/14/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B9%8B%E4%BB%8E%E8%A3%B8%E6%9C%BA%E5%88%B0%E5%8F%AF%E7%94%A8/"/>
    <id>https://zhongwuzw.github.io/2017/03/14/服务器之从裸机到可用/</id>
    <published>2017-03-14T04:16:24.000Z</published>
    <updated>2017-04-24T15:03:47.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>对于服务器，程序员们还是很熟悉的，任何一个互联网产品，背后几乎都离不开服务器，所有的服务，背后都是通过服务器来提供的，接下来，我将列出从裸机到可用的基本步骤，示例的服务器为<code>HP ProLiant Gen9</code>，当然，其他的服务器如<code>IBM</code>等，基本步骤也都是类似的。</p>
<h2 id="配置管理口"><a href="#配置管理口" class="headerlink" title="配置管理口"></a>配置管理口</h2><hr>
<p>通常来说，这一步是都是要走的，通过配置管理口，可以远程管理服务器，不用去机房插显示器、键盘。<code>HP ProLiant Gen9</code>的管理口称为<code>iLO</code>口，开机初始化后进入系统配置，进行配置，一般来说，服务器都是使用静态IP，所以需要禁掉<code>DHCP</code>，并配置<code>IP</code>地址、网关、子网掩码。重启后生效，这样就能够进行远程控制了。</p>
<h2 id="做RAID"><a href="#做RAID" class="headerlink" title="做RAID"></a>做RAID</h2><hr>
<p><a href="https://en.wikipedia.org/wiki/RAID" target="_blank" rel="external">磁盘阵列</a>（Redundant Arrays of Independent Disks，RAID），是由独立磁盘构成的具有冗余能力的阵列，将数据切割成许多区段，分别放在各个硬盘上，同时有冗余，数据重构等安全服务。</p>
<p>做RAID有很多种方案，可以根据不同的需求，使用不同的方案，如RAID0（条带）、RAID1（镜像）、RAID5、RAID10、RAID50等（不同的方法，所要求的磁盘数也不一样），通常，对于存放数据的磁盘，会使用RAID10、RAID50。做完RAID后，就形成了逻辑分区。</p>
<p>当然，并不是说服务器一定要做RAID，不做RAID的服务器也能装系统。</p>
 <a id="more"></a>
<h2 id="装系统"><a href="#装系统" class="headerlink" title="装系统"></a>装系统</h2><hr>
<p>这一步，大家应该比较熟悉了，装系统，<code>Linux</code>、<code>CentOS</code>等，如果有<code>ISO</code>镜像，通过iLO管理口，挂载镜像，启动后，就能进行系统安装，系统安装的过程中，有一步操作是挂载点设置（系统会安装在之前配置好的一个逻辑分区中），一般来说，<code>Linux</code>系统最少有两个挂载点，分别是<code>/</code>根目录、<code>swap</code>交换分区，通常，也会挂载<code>/home</code>、<code>/usr</code>、<code>/var</code>、<code>/opt</code>等目录。</p>
<h2 id="挂载磁盘"><a href="#挂载磁盘" class="headerlink" title="挂载磁盘"></a>挂载磁盘</h2><hr>
<p>系统安装完后，对之前创建好的逻辑分区进行挂载，包括格式化、创建目录、挂载磁盘以及自动挂载配置。</p>
<h2 id="配置网口IP"><a href="#配置网口IP" class="headerlink" title="配置网口IP"></a>配置网口IP</h2><hr>
<p>整个安装过程，除了给<code>iLO</code>管理口配置<code>IP</code>地址，还要配置业务口，业务口一般使用光口（光纤传输），同样给其配置IP、网关、子网掩码等。</p>
<h2 id="完"><a href="#完" class="headerlink" title="完"></a>完</h2><hr>
<p>经过这几个步骤，系统就算完成了基本的搭建，当然，还有很多另外的操作，比如配置<code>yum</code>源、配置环境、系统优化等。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;对于服务器，程序员们还是很熟悉的，任何一个互联网产品，背后几乎都离不开服务器，所有的服务，背后都是通过服务器来提供的，接下来，我将列出从裸机到可用的基本步骤，示例的服务器为&lt;code&gt;HP ProLiant Gen9&lt;/code&gt;，当然，其他的服务器如&lt;code&gt;IBM&lt;/code&gt;等，基本步骤也都是类似的。&lt;/p&gt;
&lt;h2 id=&quot;配置管理口&quot;&gt;&lt;a href=&quot;#配置管理口&quot; class=&quot;headerlink&quot; title=&quot;配置管理口&quot;&gt;&lt;/a&gt;配置管理口&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;通常来说，这一步是都是要走的，通过配置管理口，可以远程管理服务器，不用去机房插显示器、键盘。&lt;code&gt;HP ProLiant Gen9&lt;/code&gt;的管理口称为&lt;code&gt;iLO&lt;/code&gt;口，开机初始化后进入系统配置，进行配置，一般来说，服务器都是使用静态IP，所以需要禁掉&lt;code&gt;DHCP&lt;/code&gt;，并配置&lt;code&gt;IP&lt;/code&gt;地址、网关、子网掩码。重启后生效，这样就能够进行远程控制了。&lt;/p&gt;
&lt;h2 id=&quot;做RAID&quot;&gt;&lt;a href=&quot;#做RAID&quot; class=&quot;headerlink&quot; title=&quot;做RAID&quot;&gt;&lt;/a&gt;做RAID&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/RAID&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;磁盘阵列&lt;/a&gt;（Redundant Arrays of Independent Disks，RAID），是由独立磁盘构成的具有冗余能力的阵列，将数据切割成许多区段，分别放在各个硬盘上，同时有冗余，数据重构等安全服务。&lt;/p&gt;
&lt;p&gt;做RAID有很多种方案，可以根据不同的需求，使用不同的方案，如RAID0（条带）、RAID1（镜像）、RAID5、RAID10、RAID50等（不同的方法，所要求的磁盘数也不一样），通常，对于存放数据的磁盘，会使用RAID10、RAID50。做完RAID后，就形成了逻辑分区。&lt;/p&gt;
&lt;p&gt;当然，并不是说服务器一定要做RAID，不做RAID的服务器也能装系统。&lt;/p&gt;
    
    </summary>
    
      <category term="系统" scheme="https://zhongwuzw.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="服务器" scheme="https://zhongwuzw.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="系统" scheme="https://zhongwuzw.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>AppDelegate解耦之JSDecoupledAppDelegate</title>
    <link href="https://zhongwuzw.github.io/2017/02/09/AppDelegate%E8%A7%A3%E8%80%A6%E4%B9%8BJSDecoupledAppDelegate/"/>
    <id>https://zhongwuzw.github.io/2017/02/09/AppDelegate解耦之JSDecoupledAppDelegate/</id>
    <published>2017-02-09T06:52:34.000Z</published>
    <updated>2017-02-09T08:43:40.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AppDelegate解耦"><a href="#AppDelegate解耦" class="headerlink" title="AppDelegate解耦"></a>AppDelegate解耦</h2><hr>
<p>说到<code>AppDelegate</code>，大家想必都不陌生，它作为应用(<code>UIApplication</code>)的委托对象，在<code>UIApplicationMain</code>方法中被创建，当发生应用相关事件时，提供开发者响应的机会。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> * argv[]) &#123;</div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">UIApplicationMain</span>(argc, argv, <span class="literal">nil</span>, <span class="built_in">NSStringFromClass</span>([AppDelegate <span class="keyword">class</span>]));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>AppDelegate</code>是<code>UIResponder</code>的子类，应用将<code>AppDelegate</code>加入响应链中。<code>UIApplication</code>作为响应链中的最上层，当<code>UIApplication</code>任然无法处理特定事件时，会将事件转发给<code>AppDelegate</code>来处理。</p>
<p><img src="http://oc54pu02q.bkt.clouddn.com/iOS_and_OSX_responder_chain_2x.png" width="500" height="" alt="" align="center"></p>
<p>当然，<code>AppDelegate</code>的主要职责还是响应应用事件，它满足<code>UIApplicationDelegate</code>协议，<code>UIApplicationDelegate</code>协议包含大量的委托方法，包括处理应用状态、状态恢复、后台下载数据、通知、URL Route等很多方面，这就会导致，随着程序的开发，<code>AppDelegate</code>将变得越来越臃肿，为了解决该问题，就需要进行解耦。</p>
<a id="more"></a>
<h2 id="JSDecoupledAppDelegate"><a href="#JSDecoupledAppDelegate" class="headerlink" title="JSDecoupledAppDelegate"></a>JSDecoupledAppDelegate</h2><hr>
<p><a href="https://github.com/JaviSoto/JSDecoupledAppDelegate" target="_blank" rel="external">JSDecoupledAppDelegate</a>的目的就是进行<code>AppDelegate</code>的解耦，接下来，将讲述一下实现原理。</p>
<p>首先为了实现解耦，需要将<code>AppDelegate</code>替换为定义好的<code>JSDecoupledAppDelegate</code>类（该类为单例模式），其相当于一个<code>Proxy</code>代理类，负责管理分发到不同的协议对象。<code>JSDecoupledAppDelegate</code>将<code>UIApplicationDelegate</code>协议进行了分类拆分，生成如下的多个协议，针对每个协议，<code>JSDecoupledAppDelegate</code>都有一个满足该协议的属性，如<code>@property (strong, nonatomic, nullable) id&lt;JSApplicationStateDelegate&gt; appStateDelegate;</code>，<code>appStateDelegate</code>用来存储满足<code>JSApplicationStateDelegate</code>协议的对象，当该协议定义的方法被调用时，将转发给委托对象进行处理。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@<span class="keyword">protocol</span> JSApplicationStateDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationDefaultOrientationDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationBackgroundFetchDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationRemoteNotificationsDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationLocalNotificationsDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationStateRestorationDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationURLResourceOpeningDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationShortcutItemDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationHealthDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationProtectedDataDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationWatchInteractionDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationExtensionDelegate;</div><div class="line">@<span class="keyword">protocol</span> JSApplicationActivityContinuationDelegate;</div></pre></td></tr></table></figure>
<p>比如，我们需要处理应用状态相关事件，新建一个处理对象，满足<code>JSApplicationStateDelegate</code>协议，在对象中定义<code>+load</code>方法，将<code>JSDecoupledAppDelegate</code>的<code>appStateDelegate</code>属性赋给自己，如下所示，再在对象中实现<code>JSApplicationStateDelegate</code>方法，这样，当应用状态相关事件产生时，该对象就能收到相关事件。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">+ (void)load</div><div class="line">&#123;</div><div class="line">    <span class="comment">[JSDecoupledAppDelegate sharedAppDelegate]</span>.appStateDelegate = <span class="comment">[<span class="comment">[self alloc]</span> init]</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样，就实现了<code>AppDelegate</code>的解耦，针对不同的应用事件类别，由不同的对象进行处理。</p>
<p>有的人就好奇了，<code>JSDecoupledAppDelegate</code>是怎么实现事件分发的呢？</p>
<p><code>JSDecoupledAppDelegate</code>重载了<code>- (BOOL)respondsToSelector:(SEL)aSelector</code>方法，为什么会选择重载这个方法呢，我们再来思考一下，平时我们实现<code>Delegate</code>委托方式时，当我们需调用委托对象的某个方法时，首先需要做的就是判断一下委托对象是否实现了该方法，即使用<code>respondsToSelector:</code>（如果不进行提前判断，当委托对象没有实现该方法时，将导致<code>Crash</code>），这也就不难解释为什么选择重载该方法了。</p>
<p>直接show code:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)respondsToSelector:(SEL)aSelector</div><div class="line">&#123;</div><div class="line">    <span class="comment">//获取委托属性名，每个协议对应一个属性，如appStateDelegate</span></div><div class="line">    <span class="built_in">NSArray</span> *delegateProperties = JSApplicationDelegateProperties();</div><div class="line"></div><div class="line">    <span class="comment">// 1. 获取定义了aSelector的协议</span></div><div class="line">    __block <span class="built_in">BOOL</span> protocolFound = <span class="literal">NO</span>;</div><div class="line">    __block <span class="built_in">BOOL</span> delegateRespondsToSelector = <span class="literal">NO</span>;</div><div class="line"></div><div class="line">    [JSApplicationDelegateSubprotocols() enumerateObjectsUsingBlock:^(<span class="built_in">NSString</span> *protocolName, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> *stop) &#123;</div><div class="line">        <span class="comment">//获取协议定义的方法</span></div><div class="line">        <span class="built_in">NSSet</span> *protocolMethods = JSSelectorListInProtocol(<span class="built_in">NSProtocolFromString</span>(protocolName));</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="built_in">BOOL</span> methodCorrespondsToThisProtocol = [protocolMethods containsObject:<span class="built_in">NSStringFromSelector</span>(aSelector)];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (methodCorrespondsToThisProtocol)</div><div class="line">        &#123;</div><div class="line">            protocolFound = <span class="literal">YES</span>;</div><div class="line"></div><div class="line">            <span class="comment">// 2. 获取协议委托对象，如appStateDelegate属性</span></div><div class="line">            <span class="keyword">id</span> delegateObjectForProtocol = [<span class="keyword">self</span> valueForKey:delegateProperties[idx]];</div><div class="line">            </div><div class="line">            <span class="comment">//判断委托对象是否实现了该方法</span></div><div class="line">            delegateRespondsToSelector = [delegateObjectForProtocol respondsToSelector:aSelector];</div><div class="line"></div><div class="line">            *stop = <span class="literal">YES</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (protocolFound)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 3. 返回委托对象是否能响应该方法</span></div><div class="line">        <span class="keyword">return</span> delegateRespondsToSelector;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 4. 如不能响应，走缺省方法处理</span></div><div class="line">        <span class="keyword">return</span> [<span class="keyword">super</span> respondsToSelector:aSelector];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="终"><a href="#终" class="headerlink" title="终"></a>终</h2>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AppDelegate解耦&quot;&gt;&lt;a href=&quot;#AppDelegate解耦&quot; class=&quot;headerlink&quot; title=&quot;AppDelegate解耦&quot;&gt;&lt;/a&gt;AppDelegate解耦&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;说到&lt;code&gt;AppDelegate&lt;/code&gt;，大家想必都不陌生，它作为应用(&lt;code&gt;UIApplication&lt;/code&gt;)的委托对象，在&lt;code&gt;UIApplicationMain&lt;/code&gt;方法中被创建，当发生应用相关事件时，提供开发者响应的机会。&lt;/p&gt;
&lt;figure class=&quot;highlight objectivec&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; main(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; argc, &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; * argv[]) &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;@autoreleasepool&lt;/span&gt; &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;UIApplicationMain&lt;/span&gt;(argc, argv, &lt;span class=&quot;literal&quot;&gt;nil&lt;/span&gt;, &lt;span class=&quot;built_in&quot;&gt;NSStringFromClass&lt;/span&gt;([AppDelegate &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt;]));&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;AppDelegate&lt;/code&gt;是&lt;code&gt;UIResponder&lt;/code&gt;的子类，应用将&lt;code&gt;AppDelegate&lt;/code&gt;加入响应链中。&lt;code&gt;UIApplication&lt;/code&gt;作为响应链中的最上层，当&lt;code&gt;UIApplication&lt;/code&gt;任然无法处理特定事件时，会将事件转发给&lt;code&gt;AppDelegate&lt;/code&gt;来处理。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://oc54pu02q.bkt.clouddn.com/iOS_and_OSX_responder_chain_2x.png&quot; width=&quot;500&quot; height=&quot;&quot; alt=&quot;&quot; align=&quot;center&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然，&lt;code&gt;AppDelegate&lt;/code&gt;的主要职责还是响应应用事件，它满足&lt;code&gt;UIApplicationDelegate&lt;/code&gt;协议，&lt;code&gt;UIApplicationDelegate&lt;/code&gt;协议包含大量的委托方法，包括处理应用状态、状态恢复、后台下载数据、通知、URL Route等很多方面，这就会导致，随着程序的开发，&lt;code&gt;AppDelegate&lt;/code&gt;将变得越来越臃肿，为了解决该问题，就需要进行解耦。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发-项目" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="源码分析" scheme="https://zhongwuzw.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="解耦" scheme="https://zhongwuzw.github.io/tags/%E8%A7%A3%E8%80%A6/"/>
    
  </entry>
  
  <entry>
    <title>Objective-C之performSelector编译器内存泄露警告</title>
    <link href="https://zhongwuzw.github.io/2017/01/19/Objective-C%E4%B9%8BperformSelector%E7%BC%96%E8%AF%91%E5%99%A8%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E8%AD%A6%E5%91%8A/"/>
    <id>https://zhongwuzw.github.io/2017/01/19/Objective-C之performSelector编译器内存泄露警告/</id>
    <published>2017-01-19T06:23:10.000Z</published>
    <updated>2017-01-19T07:44:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<blockquote>
<p>performSelector may cause a leak because its selector is unknown</p>
</blockquote>
<p>在<code>ARC</code>环境下，我们使用<code>-(id)performSelector:</code>方法时，编译器会提示可能导致内存泄露的警告。大家如果一直使用<code>ARC</code>进行<code>iOS</code>开发，没有经历<code>MRC</code>时期的话，可能心里会有疑问，为什么<code>Apple</code>提供的<code>API</code>会报警告呢，又为什么会报内存泄露的警告？接下来，将详细讨论该问题。</p>
<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><hr>
<p>其实，产生该问题的原因是<code>ARC</code>,运行时系统需要知道调用方法的返回值类型，我们知道，方法的返回值包括：<code>void</code>,<code>int</code>,<code>NSString *</code>,<code>id</code>等，<code>ARC</code>通常可以通过定义实例方法对象的头中获取信息。</p>
<p><code>ARC</code>对于返回值有3种处理情况：</p>
<ol>
<li>忽略非对象类型（<code>void</code>,<code>int</code>等）</li>
<li>当新建对象值不再需要时<code>release</code>（如<code>init</code>,<code>copy</code>或带有<code>ns_returns_retained</code>属性的方法）</li>
<li>不做任何处理，且假设返回的对象值会在局部作用域内有效（在最里层的<code>autorelease pool</code>结束之前都有效)</li>
</ol>
<p>调用<code>-(id)performSelector:</code>，编译器会假设调用方法的返回值是一个对象，且不会对返回值进行<code>retain</code>/<code>release</code>，所以，如果你调用如上讨论的第2种情况下的方法，将导致内存泄露，因为，调用的方法会返回一个新的对象。</p>
<p>如果<code>#SEL</code>返回值类型为<code>void</code>或非对象类型，是可以安全的使用<code>-(id)performSelector:</code>的。</p>
<a id="more"></a>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><hr>
<ol>
<li><p>使用编译器指令移除警告。(注意，该方法治标不治本，对于上面讨论的内存泄露情况，仍然存在）</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">"-Warc-performSelector-leaks"</span></span></div><div class="line">[self performSelector: NSSelectorFromString(@<span class="string">"someMethod"</span>) withObject: <span class="literal">nil</span>];</div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></div></pre></td></tr></table></figure>
</li>
<li><p>使用<code>NSInvocation</code>封装方法调用。</p>
</li>
<li><p>对于返回值为<code>void</code>,<code>int</code>等值类型，可以使用<code>- performSelector:withObject:afterDelay:</code>来执行，由于它不会在当前<code>RunLoop</code>时调用，所以会立即返回，且在接下来的某个<code>RunLoop</code>中执行，也就没有了返回值。也可以使用运行时方法<code>objc_msgSend(self, NSSelectorFromString(@&quot;someMethod&quot;));</code>。</p>
</li>
</ol>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><code>Swift</code>已经废弃了<code>-(id)performSelector:</code>方法。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;performSelector may cause a leak because its selector is unknown&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在&lt;code&gt;ARC&lt;/code&gt;环境下，我们使用&lt;code&gt;-(id)performSelector:&lt;/code&gt;方法时，编译器会提示可能导致内存泄露的警告。大家如果一直使用&lt;code&gt;ARC&lt;/code&gt;进行&lt;code&gt;iOS&lt;/code&gt;开发，没有经历&lt;code&gt;MRC&lt;/code&gt;时期的话，可能心里会有疑问，为什么&lt;code&gt;Apple&lt;/code&gt;提供的&lt;code&gt;API&lt;/code&gt;会报警告呢，又为什么会报内存泄露的警告？接下来，将详细讨论该问题。&lt;/p&gt;
&lt;h2 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;headerlink&quot; title=&quot;原因&quot;&gt;&lt;/a&gt;原因&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;其实，产生该问题的原因是&lt;code&gt;ARC&lt;/code&gt;,运行时系统需要知道调用方法的返回值类型，我们知道，方法的返回值包括：&lt;code&gt;void&lt;/code&gt;,&lt;code&gt;int&lt;/code&gt;,&lt;code&gt;NSString *&lt;/code&gt;,&lt;code&gt;id&lt;/code&gt;等，&lt;code&gt;ARC&lt;/code&gt;通常可以通过定义实例方法对象的头中获取信息。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ARC&lt;/code&gt;对于返回值有3种处理情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;忽略非对象类型（&lt;code&gt;void&lt;/code&gt;,&lt;code&gt;int&lt;/code&gt;等）&lt;/li&gt;
&lt;li&gt;当新建对象值不再需要时&lt;code&gt;release&lt;/code&gt;（如&lt;code&gt;init&lt;/code&gt;,&lt;code&gt;copy&lt;/code&gt;或带有&lt;code&gt;ns_returns_retained&lt;/code&gt;属性的方法）&lt;/li&gt;
&lt;li&gt;不做任何处理，且假设返回的对象值会在局部作用域内有效（在最里层的&lt;code&gt;autorelease pool&lt;/code&gt;结束之前都有效)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;调用&lt;code&gt;-(id)performSelector:&lt;/code&gt;，编译器会假设调用方法的返回值是一个对象，且不会对返回值进行&lt;code&gt;retain&lt;/code&gt;/&lt;code&gt;release&lt;/code&gt;，所以，如果你调用如上讨论的第2种情况下的方法，将导致内存泄露，因为，调用的方法会返回一个新的对象。&lt;/p&gt;
&lt;p&gt;如果&lt;code&gt;#SEL&lt;/code&gt;返回值类型为&lt;code&gt;void&lt;/code&gt;或非对象类型，是可以安全的使用&lt;code&gt;-(id)performSelector:&lt;/code&gt;的。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS开发-语言" scheme="https://zhongwuzw.github.io/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="iOS" scheme="https://zhongwuzw.github.io/tags/iOS/"/>
    
      <category term="Objective-C" scheme="https://zhongwuzw.github.io/tags/Objective-C/"/>
    
  </entry>
  
  <entry>
    <title>SSO单点登录之CAS-Server</title>
    <link href="https://zhongwuzw.github.io/2016/12/27/SSO%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95%E4%B9%8BCAS-Server/"/>
    <id>https://zhongwuzw.github.io/2016/12/27/SSO单点登录之CAS-Server/</id>
    <published>2016-12-27T10:15:15.000Z</published>
    <updated>2017-06-15T02:02:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Prerequisites"><a href="#Prerequisites" class="headerlink" title="Prerequisites"></a>Prerequisites</h2><hr>
<ul>
<li><code>CAS Server 3.5.x.</code>，下文以<code>$CAS-SERVER</code>表示。</li>
<li><code>CAS Client 3.3.x.</code>，下文以<code>$CAS-CLIENT</code>表示。</li>
<li><code>Tomcat 7.x</code>，下文以<code>$CAS_TOMCAT_HOME</code>表示。</li>
<li><code>GateIn-3.8.1.Final-tomcat-7</code>，下文以<code>$GATEIN_HOME</code>表示。</li>
</ul>
<blockquote>
<p>最近公司需要对之前的多个Web应用系统进行整合，希望用户在登录某个应用系统时，能直接访问其他的Web应用系统，且不需要再次登录。既我们经常说的单点登录，最后，我选择了<a href="https://www.apereo.org/projects/cas/download-cas" target="_blank" rel="external"><code>CAS</code></a>，并将其整合进了<a href="http://gatein.jboss.org/" target="_blank" rel="external">GateIn portal</a>。接下来，将整理一下原理和整合步骤。<br>所有项目代码示例可在<a href="https://github.com/CAS-GateInPortal" target="_blank" rel="external">github</a>上下载。</p>
</blockquote>
<h2 id="CAS介绍"><a href="#CAS介绍" class="headerlink" title="CAS介绍"></a>CAS介绍</h2><hr>
<p><a href="https://www.apereo.org/projects/cas/download-cas" target="_blank" rel="external"><code>CAS</code></a>（Central Authentication Service）是<code>Yale</code>大学发起的一个开源项目，旨在为<code>Web</code>应用系统提供一种可靠的单点登录。单点登录，既在多个应用系统中，用户只需登录一次就可以访问所有相互信任的应用系统。<code>CAS Client</code>支持非常多的客户端，包括<code>JAVA、PHP、Ruby</code>等。</p>
<p>接下来，接介绍一下<code>CAS</code>系统。</p>
<h3 id="CAS-系统组成"><a href="#CAS-系统组成" class="headerlink" title="CAS 系统组成"></a>CAS 系统组成</h3><hr>
<p><code>CAS</code>系统架构由两部分组成，<code>CAS Server</code>、<code>CAS Clients</code>，两者可以通过多种协议进行通信。</p>
<a id="more"></a>
<h4 id="CAS-Server"><a href="#CAS-Server" class="headerlink" title="CAS Server"></a>CAS Server</h4><hr>
<p><code>CAS Server</code>是一个构建在<code>Spring Framework</code>上的<code>Java servlet</code>，通过分配和诊断<code>tickets</code>，负责认证用户以及授权。</p>
<h4 id="CAS-Clients"><a href="#CAS-Clients" class="headerlink" title="CAS Clients"></a>CAS Clients</h4><hr>
<p><code>CAS Clients</code>负责对用户的认证工作，<code>CAS Clients</code>负责处理对客户端受保护资源的访问请求，需要登录时，重定向到<code>CAS Server</code>。</p>
<p><code>CAS Clients</code>与受保护的客户端应用部署在一起，以<code>Filter</code>方式保护受保护的资源。</p>
<h3 id="CAS协议流程"><a href="#CAS协议流程" class="headerlink" title="CAS协议流程"></a>CAS协议流程</h3><hr>
<p>CAS协议流程如下图所示，展示了用户同时访问多个应用系统的流程。多个应用系统能实现单点登录的基本流程为，当用户首次访问需要登录才能访问的页面时，会自动重定向到<code>CAS Server</code>的登陆页面，成功认证完后，会在<code>CAS Server</code>的域中设置<code>CASTGC</code>的<code>Cookie</code>，最终登陆完成后，服务器会创建一个<code>session</code>会话，用于之后与应用系统的交互。当用户同时再登陆另外一个应用系统时，同样会跟之前一样，重定向到<code>CAS Server</code>的登陆页面，区别是此时已经有了<code>CAS Server</code>域中的<code>CASTGC</code>，重定向时会附带该<code>Cookie</code>，<code>CAS Server</code>验证之后返回一个<code>ticket</code>，之后浏览器重新请求原访问页面，并附带<code>ticket</code>参数，<code>CAS Server</code>诊断有效后，返回原应用系统的重定向，且设置该域的<code>session Cookie</code>，浏览器最后请求原页面，并附带<code>session Cookei</code>，应用系统诊断后返回请求内容。</p>
<p>需要注意的是，当成功登陆完某个系统后，如果继续再访问该系统的其他资源页面，是不需要再次与<code>CAS Server</code>进行交互的，应用系统将根据<code>session</code>直接进行诊断。</p>
<p><img src="http://oc54pu02q.bkt.clouddn.com/cas_flow_diagram.png" alt=""></p>
<h2 id="GateIn-Portal集成CAS-Server"><a href="#GateIn-Portal集成CAS-Server" class="headerlink" title="GateIn Portal集成CAS Server"></a>GateIn Portal集成CAS Server</h2><hr>
<h3 id="部署CAS"><a href="#部署CAS" class="headerlink" title="部署CAS"></a>部署CAS</h3><hr>
<ol>
<li><p>打开<code>$CAS_TOMCAT_HOME/webapps/$CAS-SERVER/WEB-INF/deployerConfigContext.xml</code>，替换：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"org.jasig.cas.authentication.handler.support.SimpleTestUsernamePasswordAuthenticationHandler"</span> /&gt;</div></pre></td></tr></table></figure>
<p>为如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"org.gatein.sso.cas.plugin.AuthenticationPlugin"</span>&gt;</div><div class="line">	   <span class="xml"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"gateInProtocol"</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>http<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></div><div class="line">	   &lt;property name=<span class="string">"gateInHost"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>localhost<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></div><div class="line">	   &lt;property name=<span class="string">"gateInPort"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>8080<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></div><div class="line">	   &lt;property name=<span class="string">"gateInContext"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>portal<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></div><div class="line">	   &lt;property name=<span class="string">"httpMethod"</span>&gt;<span class="xml"><span class="tag">&lt;<span class="name">value</span>&gt;</span>POST<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span></div><div class="line">&lt;<span class="regexp">/bean&gt;</span></div></pre></td></tr></table></figure>
<p> 如上所示，用来配置<code>GateIn Portal</code>的服务地址。</p>
</li>
<li><p>下载<code>GateIn SSO package</code>，<a href="https://repository.jboss.org/nexus/content/groups/public/org/gatein/sso/sso-packaging/1.4.1.Final/sso-packaging-1.4.1.Final.zip" target="_blank" rel="external">下载地址</a>，解压后，将其<code>cas/plugin/WEB-INF/lib</code>下的<code>jar</code>包拷贝到<code>$CAS_TOMCAT_HOME/webapps/$CAS-SERVER/WEB-INF/lib</code>目录。</p>
</li>
<li>默认，登出用户时<code>CAS Server</code>会展示一个<code>CAS</code>提供的登出页面，然后跳转回<code>Portal</code>页，如果想要保留原有<code>Portal</code>的登出，打开<code>$CAS_TOMCAT_HOME/webapps/$CAS-SERVER/WEB-INF/cas-servlet.xml</code>，添加<code>followServiceRedirects=&quot;true&quot;</code>参数：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"> &lt;bean id=<span class="string">"logoutController"</span>  class=<span class="string">"org.jasig.cas.web.LogoutController"</span></div><div class="line"><span class="selector-tag">p</span>:centralAuthenticationService-ref=<span class="string">"centralAuthenticationService"</span></div><div class="line"><span class="selector-tag">p</span>:logoutView=<span class="string">"casLogoutView"</span></div><div class="line"><span class="selector-tag">p</span>:warnCookieGenerator-ref=<span class="string">"warnCookieGenerator"</span></div><div class="line"><span class="selector-tag">p</span>:ticketGrantingTicketCookieGenerator-ref=<span class="string">"ticketGrantingTicketCookieGenerator"</span></div><div class="line"><span class="selector-tag">p</span>:followServiceRedirects=<span class="string">"true"</span>/&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="部署GateIn-Portal"><a href="#部署GateIn-Portal" class="headerlink" title="部署GateIn Portal"></a>部署GateIn Portal</h3><hr>
<ol>
<li><p>为了能让<code>Portal</code>使用<code>CAS Server</code>提供的单点登陆系统，首先配置<code>Portal</code>的<code>SSO</code>参数，在<code>$GATEIN_HOME/gatein/conf/configuration.properties</code>文件中，修改和添加如下内容：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">gatein.sso.enabled=true</div><div class="line">gatein.sso.callback.enabled=$&#123;<span class="attribute">gatein.sso.enabled&#125;</span></div><div class="line">gatein.sso.login.module.enabled=$&#123;gatein.sso.enabled&#125;</div><div class="line">gatein.sso.login.module.class=org.gatein.sso.agent.login.SSOLoginModule</div><div class="line">gatein.sso.server.url=http://localhost:8086/cas-server</div><div class="line">gatein<span class="variable">.sso</span><span class="variable">.portal</span><span class="variable">.url</span>=http://localhost:8080</div><div class="line">gatein<span class="variable">.sso</span><span class="variable">.filter</span><span class="variable">.logout</span><span class="variable">.class</span>=org<span class="variable">.gatein</span><span class="variable">.sso</span><span class="variable">.agent</span><span class="variable">.filter</span><span class="variable">.CASLogoutFilter</span></div><div class="line">gatein<span class="variable">.sso</span><span class="variable">.filter</span><span class="variable">.logout</span><span class="variable">.url</span>=$&#123;gatein<span class="variable">.sso</span><span class="variable">.server</span><span class="variable">.url</span>&#125;/logout</div><div class="line">gatein<span class="variable">.sso</span><span class="variable">.filter</span><span class="variable">.login</span><span class="variable">.sso</span><span class="variable">.url</span>=$&#123;gatein<span class="variable">.sso</span><span class="variable">.server</span><span class="variable">.url</span>&#125;/login?service=$&#123;gatein<span class="variable">.sso</span><span class="variable">.portal</span><span class="variable">.url</span>&#125;/@@portal<span class="variable">.container</span><span class="variable">.name</span>@@/initiatessologin</div></pre></td></tr></table></figure>
<p> 如上，为配置<code>CAS Server</code>的服务器信息等。</p>
</li>
<li><p>如果需要改变账户系统的存储方式， 比如改为<code>MySQL</code>数据库，还需要在<code>$GATEIN_HOME/gatein/conf/configuration.properties</code>文件中修改成如下所示，同时，下载<code>mysql-connect-java.jar``jar</code>包，放入<code>$GATEIN_HOME/lib</code>目录下。</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">gatein<span class="selector-class">.idm</span><span class="selector-class">.datasource</span><span class="selector-class">.name</span>=jdbcidm</div><div class="line">gatein<span class="selector-class">.idm</span><span class="selector-class">.datasource</span><span class="selector-class">.driver</span>=com<span class="selector-class">.mysql</span><span class="selector-class">.jdbc</span><span class="selector-class">.Driver</span></div><div class="line">gatein<span class="selector-class">.idm</span><span class="selector-class">.datasource</span><span class="selector-class">.url</span>=jdbc:mysql:<span class="comment">//localhost:3306/jdbcidm_$&#123;name&#125;</span></div><div class="line">gatein<span class="selector-class">.idm</span><span class="selector-class">.datasource</span><span class="selector-class">.username</span>=root</div><div class="line">gatein<span class="selector-class">.idm</span><span class="selector-class">.datasource</span><span class="selector-class">.password</span>=<span class="number">123</span></div></pre></td></tr></table></figure>
<p> 在<code>$GATEIN_HOME/conf/server.xml</code>的<code>&lt;GlobalNamingResources&gt;&lt;/GlobalNamingResources&gt;</code>节点中声明绑定的数据源，添加如下，字段含义可参考<a href="https://www.exoplatform.com/docs/public/index.jsp?topic=%2FPLF35%2FADM.Configuration.Connect_To_A_Production_Database.html" target="_blank" rel="external">该文</a>，注意，数据库名必须为<code>jdbcidm_portal</code>，且需要提前手动创建，无法自动创建，但是<code>GateIn Portal</code>会自动创建用户相关表：</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;Resource auth=<span class="string">"Container"</span> driverClassName=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="built_in">log</span>Abandoned=<span class="string">"true"</span> maxActive=<span class="string">"20"</span> maxIdle=<span class="string">"10"</span> maxWait=<span class="string">"10000"</span> minEvictableIdleTimeMillis=<span class="string">"60000"</span> name=<span class="string">"exo-idm_portal"</span> password=<span class="string">"123"</span> removeAbandoned=<span class="string">"true"</span> removeAbandonedTimeout=<span class="string">"10"</span> <span class="built_in">type</span>=<span class="string">"javax.sql.DataSource"</span> url=<span class="string">"jdbc:mysql://localhost:3306/jdbcidm_portal"</span> username=<span class="string">"root"</span>/&gt;</div></pre></td></tr></table></figure>
<p> 在<code>GateIn Portal</code>与<code>CAS</code>整合后，账户系统将由<code>GateIn Portal</code>接管，也就是说，如果<code>GateIn Portal</code>服务没有开启，则<code>CAS Server</code>将无法进行认证。</p>
</li>
<li><p>在<code>$GATEIN_HOME/conf/server.xml</code>的<code>Host</code>元素下添加<code>ServletAccessValve</code>，如：</p>
 <figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;Host <span class="built_in">name</span>=<span class="string">"localhost"</span> appBase=<span class="string">"webapps"</span></div><div class="line">  unpackWARs=<span class="string">"true"</span> autoDeploy=<span class="string">"true"</span>&gt;</div><div class="line"> </div><div class="line">  &lt;Valve className=<span class="string">"org.gatein.sso.agent.tomcat.ServletAccessValve"</span> /&gt;</div><div class="line"> </div><div class="line">  &lt;!<span class="comment">-- SingleSignOn valve, share authentication between web applications</span></div><div class="line">  ...</div></pre></td></tr></table></figure>
<p> 其目的是开启<code>SSO</code>组件，将其加入<code>Catalina</code>容器的请求处理管道中，这样，<code>SSO</code>组件将有机会处理每一个<code>Request</code>请求。</p>
</li>
</ol>
<h2 id="修改portal项目根路径"><a href="#修改portal项目根路径" class="headerlink" title="修改portal项目根路径"></a>修改portal项目根路径</h2><hr>
<p><code>GateIn portal</code>项目的默认网址格式为：<code>{ip}:{port}/portal/*</code>，如果我们想把根路径的<code>portal</code>改成其他的，如<code>ots-portal</code>，并不能简单的像其他<code>Tomcat``webapp</code>一样，直接修改目录名即可，因为<code>portal</code>有多个应用依赖，且<code>portal</code>关键字还作为容器名等在整个生命周期中起作用，最终经过大量分析测试，实现了更名，接下来，将总结修改的配置文件：</p>
<ul>
<li><code>$GATEIN_HOME/conf/jaas.conf</code>：<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">  gatein-domain &#123;</div><div class="line">  <span class="keyword">org.exoplatform.web.login.FilterDisabledLoginModule </span>required</div><div class="line">    portalContainerName=ots-portal</div><div class="line">    realmName=gatein-domain<span class="comment">;</span></div><div class="line">  <span class="keyword">org.gatein.security.oauth.jaas.OAuthLoginModule </span>required</div><div class="line">    portalContainerName=ots-portal</div><div class="line">    realmName=gatein-domain<span class="comment">;</span></div><div class="line">  <span class="keyword">org.gatein.sso.integration.SSODelegateLoginModule </span>required</div><div class="line">    enabled=<span class="string">"#&#123;gatein.sso.login.module.enabled&#125;"</span></div><div class="line">    delegateClassName=<span class="string">"#&#123;gatein.sso.login.module.class&#125;"</span></div><div class="line">    portalContainerName=ots-portal</div><div class="line">    realmName=gatein-domain</div><div class="line">    password-stacking=useFirstPass<span class="comment">;</span></div><div class="line">  <span class="keyword">org.exoplatform.services.security.j2ee.TomcatLoginModule </span>required</div><div class="line">    portalContainerName=ots-portal</div><div class="line">    realmName=gatein-domain<span class="comment">;</span></div><div class="line">&#125;<span class="comment">;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>$GATEIN_HOME/gatein/conf/configuration.xml</code>：<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">object-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>portal<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">object</span> <span class="attr">type</span>=<span class="string">"org.exoplatform.container.definition.PortalContainerDefinition"</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!-- The name of the portal container --&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>ots-portal<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">field</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!-- The name of the context name of the rest web application --&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"restContextName"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>rest<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">          <span class="tag">&lt;/<span class="name">field</span>&gt;</span></div><div class="line">          <span class="comment">&lt;!-- The name of the realm --&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"realmName"</span>&gt;</span></div><div class="line">          <span class="tag">&lt;<span class="name">string</span>&gt;</span>gatein-domain<span class="tag">&lt;/<span class="name">string</span>&gt;</span></div><div class="line">      <span class="tag">&lt;/<span class="name">field</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">object</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">object-param</span>&gt;</span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>$GATEIN_HOME/webapps/ots-portal/WEB-INF/web.xml</code>：<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;display-<span class="built_in">name</span>&gt;ots-portal&lt;/display-<span class="built_in">name</span>&gt;</div><div class="line">&lt;context-<span class="built_in">param</span>&gt;</div><div class="line">  &lt;<span class="built_in">param</span>-<span class="built_in">name</span>&gt;org.exoplatform.frameworks.jcr.command.web.fckeditor.digitalAssetsWorkspace&lt;/<span class="built_in">param</span>-<span class="built_in">name</span>&gt;</div><div class="line">  &lt;<span class="built_in">param</span>-value&gt;ots-portal&lt;/<span class="built_in">param</span>-value&gt;</div><div class="line">&lt;/context-<span class="built_in">param</span>&gt;</div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><code>$GATEIN_HOME/webapps/ROOT/index.jsp</code>：<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="xml"></span><span class="vbscript">&lt;%</span></div><div class="line"><span class="built_in">response</span>.setStatus(<span class="built_in">response</span>.SC_MOVED_TEMPORARILY);</div><div class="line"><span class="built_in">response</span>.setHeader(<span class="string">"Location"</span>, <span class="string">"/ots-portal"</span>);</div><div class="line">%&gt;<span class="xml"></span></div></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>最后，当然同样需要将<code>portal</code>目录名改为<code>ots-portal</code>。</li>
</ul>
<p>如上修改之后，就可以通过网址<code>{ip}:{port}/ots-portal/*</code>来进行访问了。</p>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><hr>
<p>更改根目录之后，其认证相关信息存储的库名将由<code>jdbcidm_portal</code>变为<code>jdbcidm_ots-portal</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-cas/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/opensource/os-cn-cas/</a></li>
<li><a href="https://www.exoplatform.com/docs/public/index.jsp?topic=%2FPLF35%2FADM.Configuration.Connect_To_A_Production_Database.html" target="_blank" rel="external">https://www.exoplatform.com/docs/public/index.jsp?topic=%2FPLF35%2FADM.Configuration.Connect_To_A_Production_Database.html</a></li>
<li><a href="https://repository.jboss.org/nexus/content/groups/public/org/gatein/sso/sso-packaging/1.4.1.Final/sso-packaging-1.4.1.Final.zip" target="_blank" rel="external">https://repository.jboss.org/nexus/content/groups/public/org/gatein/sso/sso-packaging/1.4.1.Final/sso-packaging-1.4.1.Final.zip</a></li>
<li><a href="http://www.cnblogs.com/vhua/p/cas_1.html" target="_blank" rel="external">http://www.cnblogs.com/vhua/p/cas_1.html</a></li>
<li><a href="https://developer.jboss.org/wiki/ChangeGateInContextPath" target="_blank" rel="external">https://developer.jboss.org/wiki/ChangeGateInContextPath</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Prerequisites&quot;&gt;&lt;a href=&quot;#Prerequisites&quot; class=&quot;headerlink&quot; title=&quot;Prerequisites&quot;&gt;&lt;/a&gt;Prerequisites&lt;/h2&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;CAS Server 3.5.x.&lt;/code&gt;，下文以&lt;code&gt;$CAS-SERVER&lt;/code&gt;表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CAS Client 3.3.x.&lt;/code&gt;，下文以&lt;code&gt;$CAS-CLIENT&lt;/code&gt;表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Tomcat 7.x&lt;/code&gt;，下文以&lt;code&gt;$CAS_TOMCAT_HOME&lt;/code&gt;表示。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;GateIn-3.8.1.Final-tomcat-7&lt;/code&gt;，下文以&lt;code&gt;$GATEIN_HOME&lt;/code&gt;表示。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;最近公司需要对之前的多个Web应用系统进行整合，希望用户在登录某个应用系统时，能直接访问其他的Web应用系统，且不需要再次登录。既我们经常说的单点登录，最后，我选择了&lt;a href=&quot;https://www.apereo.org/projects/cas/download-cas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;CAS&lt;/code&gt;&lt;/a&gt;，并将其整合进了&lt;a href=&quot;http://gatein.jboss.org/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;GateIn portal&lt;/a&gt;。接下来，将整理一下原理和整合步骤。&lt;br&gt;所有项目代码示例可在&lt;a href=&quot;https://github.com/CAS-GateInPortal&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;github&lt;/a&gt;上下载。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;CAS介绍&quot;&gt;&lt;a href=&quot;#CAS介绍&quot; class=&quot;headerlink&quot; title=&quot;CAS介绍&quot;&gt;&lt;/a&gt;CAS介绍&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;&lt;a href=&quot;https://www.apereo.org/projects/cas/download-cas&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;&lt;code&gt;CAS&lt;/code&gt;&lt;/a&gt;（Central Authentication Service）是&lt;code&gt;Yale&lt;/code&gt;大学发起的一个开源项目，旨在为&lt;code&gt;Web&lt;/code&gt;应用系统提供一种可靠的单点登录。单点登录，既在多个应用系统中，用户只需登录一次就可以访问所有相互信任的应用系统。&lt;code&gt;CAS Client&lt;/code&gt;支持非常多的客户端，包括&lt;code&gt;JAVA、PHP、Ruby&lt;/code&gt;等。&lt;/p&gt;
&lt;p&gt;接下来，接介绍一下&lt;code&gt;CAS&lt;/code&gt;系统。&lt;/p&gt;
&lt;h3 id=&quot;CAS-系统组成&quot;&gt;&lt;a href=&quot;#CAS-系统组成&quot; class=&quot;headerlink&quot; title=&quot;CAS 系统组成&quot;&gt;&lt;/a&gt;CAS 系统组成&lt;/h3&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;CAS&lt;/code&gt;系统架构由两部分组成，&lt;code&gt;CAS Server&lt;/code&gt;、&lt;code&gt;CAS Clients&lt;/code&gt;，两者可以通过多种协议进行通信。&lt;/p&gt;
    
    </summary>
    
      <category term="Web开发" scheme="https://zhongwuzw.github.io/categories/Web%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="SSO" scheme="https://zhongwuzw.github.io/tags/SSO/"/>
    
      <category term="CAS" scheme="https://zhongwuzw.github.io/tags/CAS/"/>
    
      <category term="Portal" scheme="https://zhongwuzw.github.io/tags/Portal/"/>
    
  </entry>
  
</feed>
