<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.3/css/all.min.css" integrity="sha256-2H3fkXt6FEmrReK448mDVGKb3WW2ZZw35gI7vqHOE4Y=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"zhongwuzw.github.io","root":"/","images":"/images","scheme":"Pisces","version":"8.7.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"}}</script><script src="/js/config.js"></script>
<meta name="description" content="Keep thinking, keep coding!!!">
<meta property="og:type" content="website">
<meta property="og:title" content="钟武的技术博客">
<meta property="og:url" content="https://zhongwuzw.github.io/index.html">
<meta property="og:site_name" content="钟武的技术博客">
<meta property="og:description" content="Keep thinking, keep coding!!!">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="钟武">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://zhongwuzw.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>钟武的技术博客</title>
  




  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">钟武的技术博客</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
  </ul>
</nav>




</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-overview">
            <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">钟武</p>
  <div class="site-description" itemprop="description">Keep thinking, keep coding!!!</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">45</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">15</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/zhongwuzw" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhongwuzw" rel="noopener" target="_blank"><i class="github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhongwuzw@qq.com" title="E-Mail → mailto:zhongwuzw@qq.com" rel="noopener" target="_blank"><i class="envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/zhongwuzw" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;zhongwuzw" rel="noopener" target="_blank"><i class="stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
      <span class="links-of-author-item">
        <a href="http://weibo.com/zhongwuzw" title="微博 → http:&#x2F;&#x2F;weibo.com&#x2F;zhongwuzw" rel="noopener" target="_blank"><i class="weibo fa-fw"></i>微博</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.douban.com/people/zhongwu/" title="豆瓣 → https:&#x2F;&#x2F;www.douban.com&#x2F;people&#x2F;zhongwu&#x2F;" rel="noopener" target="_blank"><i class="share-alt fa-fw"></i>豆瓣</a>
      </span>
  </div>



          </div>
        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2020/09/24/Flutter-InheritedWidget%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/24/Flutter-InheritedWidget%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/" class="post-title-link" itemprop="url">Flutter InheritedWidget实现原理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-24 10:50:54 / 修改时间：10:55:42" itemprop="dateCreated datePublished" datetime="2020-09-24T10:50:54+08:00">2020-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p>在Flutter开发中，对于一些简单的数据传递，我们可以使用Widget constructor直接传递进去，但是当某个后代Widget依赖上层的祖先Widget或者多个Widget同时依赖祖先Widget的情形时，直接传递的方式就会暴露出很多的问题：需要连续传递很难维护以及依赖的祖先Widget数据改变时，所有子Widget都需要rebuild。</p>
<p>Flutter提供了另外一个机制来解决这个问题，InheritedWidget，当InheritedWidget数据发生变化时，只通知依赖其数据变化的Widgets，接下来将按步骤分析实现细节。（ <a target="_blank" rel="noopener" href="https://github.com/rrousselGit/provider?spm=ata.13261165.0.0.36547ede70zxv7">Provider</a>也是基于InheritedWidget进行的封装）</p>
<p><img src="/images/flutter_inheritedWidget.png"></p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><hr>
<p>我们通过一个小demo来展示使用方法，假设数据Color需要被后代Widget访问，且当Color变化，后代Widget能监听到变化。步骤比较简单，先子类InheritedWidget，如下代码示例，FrogColor定义了一个名为of的静态方法，该方法由后代Widget进行调用，调用时将后代Widget的Element作为context传入。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class FrogColor extends InheritedWidget &#123;</span><br><span class="line">  const FrogColor(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    @required this.color,</span><br><span class="line">    @required Widget child,</span><br><span class="line">  &#125;) : assert(color != null),</span><br><span class="line">       assert(child != null),</span><br><span class="line">       super(key: key, child: child);</span><br><span class="line"></span><br><span class="line">  final Color color;</span><br><span class="line"></span><br><span class="line">  static FrogColor of(BuildContext context) &#123;</span><br><span class="line">    return context.dependOnInheritedWidgetOfExactType&lt;FrogColor&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @override</span><br><span class="line">  bool updateShouldNotify(FrogColor old) =&gt; color != old.color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们看下of静态方法的实现，实际调用的是后代Widget对应Element的 dependOnInheritedWidgetOfExactType，该方法首先会去_inheritedWidgets里找是否有需要的InheritedWidget，如果找到，返回找到的InheritedWidget，并将自己作为依赖注册到InheritedWidget里，这样InheritedWidget就能知道哪些Widget依赖它，如果InheritedWidget发生了变化，会通知依赖方。_inheritedWidgets会在InheritedWidget mount的时候从父Element获取当前所有的InheritedWidgets，并且把自己也加到里边，也就是说，所有的Element都有一个Map来收集当前祖先所有的InheritedWidget。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">T dependOnInheritedWidgetOfExactType&lt;T extends InheritedWidget&gt;(&#123;Object aspect&#125;) &#123;</span><br><span class="line">  assert(_debugCheckStateIsActiveForAncestorLookup());</span><br><span class="line">  final InheritedElement ancestor = _inheritedWidgets == null ? null : _inheritedWidgets[T];</span><br><span class="line">  if (ancestor != null) &#123;</span><br><span class="line">    assert(ancestor is InheritedElement);</span><br><span class="line">    return dependOnInheritedElement(ancestor, aspect: aspect) as T;</span><br><span class="line">  &#125;</span><br><span class="line">  _hadUnsatisfiedDependencies = true;</span><br><span class="line">  return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新回到FrogColor类，另一个方法updateShouldNotify，当FrogColor widget rebuild时，FrogColor的Element会通过updated方法来判断是否需要通知所有依赖它的后代Widgets，super.updated(oldWidget)用来通知所有的dependencies 依赖方。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@override</span><br><span class="line">void updated(InheritedWidget oldWidget) &#123;</span><br><span class="line">  if (widget.updateShouldNotify(oldWidget))</span><br><span class="line">    super.updated(oldWidget);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当需要通知依赖方的时候，调用依赖Widget对应Element的didChangeDependencies方法，Element将自己标记为dirty，并加到BuildOwner的dirty列表中，当下一帧绘制时，会重新build Widget。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@mustCallSuper</span><br><span class="line">void didChangeDependencies() &#123;</span><br><span class="line">  assert(_active); // otherwise markNeedsBuild is a no-op</span><br><span class="line">  assert(_debugCheckOwnerBuildTargetExists(&#x27;didChangeDependencies&#x27;));</span><br><span class="line">  markNeedsBuild();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<p>综上，我们可以看到，InheritedWidget不仅能解决多层传递带来的业务复杂度，也能非常高效的进行rebuild操作。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2020/09/24/Flutter-Dart%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2020/09/24/Flutter-Dart%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/" class="post-title-link" itemprop="url">Flutter Dart垃圾回收</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2020-09-24 10:15:48 / 修改时间：10:50:38" itemprop="dateCreated datePublished" datetime="2020-09-24T10:15:48+08:00">2020-09-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Flutter/" itemprop="url" rel="index"><span itemprop="name">Flutter</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<p>Flutter使用Dart作为开发语言以及运行时，Dart 运行时存在于Debug和Release模式，不过两个模式中的运行时有很大的区别。</p>
<p>Debug模式下，Dart运行时，JIT编译器/解释器（Android是JIT，iOS是解释器），Debug和Profile工具都会加载到设备上。而Release模式下，JIT编译器/解释器和Debug服务被移除，只包括运行时。</p>
<p><img src="/images/flutter_debug_release.png"></p>
<p> Dart运行时包含垃圾回收器，在对象创建和销毁时分配和释放内存。Flutter在运行中，会创建大量的对象，比如，伴随着在界面展示，不可见，app 状态变化等，会创建很多Staleless Widgets，其中很多生命周期都很短。一个比较复杂的UI界面，widgets数量能上千。</p>
<p> 那么Flutter 开发者是否需要关心垃圾回收？Flutter在高频次创建和销毁对象的情况下，开发者是否需要采取措施来限制这种行为？很多人会对不会变的widgets创建引用，保存在state中，来避免重建和销毁。其实这些是没有必要的，因为Dart垃圾回收器基于分代架构，且针对对象的快速创建和销毁做了优化，大多数情况下，让引擎自己管理所有widgets创建和销毁即可。</p>
<h2 id="Dart垃圾回收器"><a href="#Dart垃圾回收器" class="headerlink" title="Dart垃圾回收器"></a>Dart垃圾回收器</h2><hr>
<p>Dart的垃圾回收器由两部分组成：新生代scavenger和并发标记清除回收器。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>为了降低垃圾回收对UI性能的影响，垃圾回收器提供了hooks给flutter engine，当没有用户交互或app处于闲时状态时，flutter engine会通知垃圾回收器来进行收集，而不会影响想能。</p>
<p>当处于闲时状态时，垃圾回收器也能进行内存碎片整理，减少内存碎片。</p>
<h3 id="年轻代Scavenger"><a href="#年轻代Scavenger" class="headerlink" title="年轻代Scavenger"></a>年轻代Scavenger</h3><p>该阶段主要用来清理生命周期短的临时对象，如stateless widgets，会比次代标记/清除阶段更快，极大减小app运行过程中可能带来的卡顿。</p>
<p>对象创建时会在一片连续的内存空间进行分配，每次创建对象，都会再这片空间区域查找是否有可用的空间，当可用空间被占满，Dart会使用bump pointer（指针碰撞）的方式来快速分配新的空间。</p>
<p>新的空间分为两部分，称为半空间，任何时候，只有一半是处于激活的，另一半则处于非激活状态。新创建的对象会在激活的那部分空间进行分配，当激活部分被占满，引用不可释放的对象会从激活空间移到非激活空间，非激活空间将变为激活空间，以此反复。</p>
<p>为了确定当前的对象是否可释放，收集器会从根对象，如栈变量，来检测是否是否还有引用，引用的对象会被移动到非激活空间，最后，剩下的对象就是可释放对象，在后续的垃圾回收时，引用对象会直接覆盖之前的可释放对象占用的空间。更多细节，参看<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Cheney%27s_algorithm?spm=ata.13261165.0.0.1f0058e56w9Oaq">Cheney’s 算法</a>。</p>
<p><img src="/images/flutter_scavenger.png"></p>
<h3 id="并行标记和并发清除"><a href="#并行标记和并发清除" class="headerlink" title="并行标记和并发清除"></a>并行标记和并发清除</h3><p>当对象到达一定的生命周期，他们会被移入新的内存空间（老年代），由次代收集器（标记/清除）进行内存管理，收集器同样分两部分：首先会遍历对象图，标记还在使用的对象。遍历完成后，未被标记的对象会被回收。</p>
<p>注意，这种形式的垃圾回收会在标记阶段阻塞UI线程，且不能进行内存修改操作。不过，这个阶段发生的频率很低，因为生命周期短的对象都被年轻代scavenger处理了。</p>
<p>当然，如果开发的app不满足弱分代假说（即大多数对象会在年轻时死亡，生命周期短）的情况，那么该形式的垃圾回收会更容易发生。</p>
<h3 id="Heap-Map"><a href="#Heap-Map" class="headerlink" title="Heap Map"></a>Heap Map</h3><p>Observatory下可以通过heap map来观察某一时刻特定Isolate老年代的内存分配，如下图，不同的颜色代表不同的内存块，白色代表空闲空间，如果我们看到很多小的白色块，说明产生了内存碎片，可能考虑有内存泄漏了。</p>
<p><img src="/images/flutter_heap_map.png"></p>
<h2 id="Isolates"><a href="#Isolates" class="headerlink" title="Isolates"></a>Isolates</h2><hr>
<p>Dart的每个Isolate有自己的堆空间，每个Isolate也都运行在单独的线程中，垃圾回收时，互不影响性能，所以Isolate可以避免阻塞UI，进行CPU密集型、IO、网络等操作。</p>
<p><img src="/images/fkutter_isolates.png"></p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://mrale.ph/dartvm/">https://mrale.ph/dartvm/</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30">https://medium.com/flutter/flutter-dont-fear-the-garbage-collector-d69b3ff1ca30</a></li>
<li><a target="_blank" rel="noopener" href="https://dart-lang.github.io/observatory/heap-map.html">https://dart-lang.github.io/observatory/heap-map.html</a></li>
<li><a target="_blank" rel="noopener" href="https://dart-lang.github.io/observatory/glossary.html?spm=ata.13261165.0.0.1f0058e56w9Oaq#memory-leak">https://dart-lang.github.io/observatory/glossary.html?spm=ata.13261165.0.0.1f0058e56w9Oaq#memory-leak</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/09/11/iOS%E4%B9%8B%E8%8E%B7%E5%8F%96Block-retain%E7%9A%84objects/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/09/11/iOS%E4%B9%8B%E8%8E%B7%E5%8F%96Block-retain%E7%9A%84objects/" class="post-title-link" itemprop="url">iOS之获取Block retain的objects</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-09-11 17:33:31 / 修改时间：18:25:30" itemprop="dateCreated datePublished" datetime="2018-09-11T17:33:31+08:00">2018-09-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">iOS开发-语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Block管理Objective-C对象实例的原理"><a href="#Block管理Objective-C对象实例的原理" class="headerlink" title="Block管理Objective-C对象实例的原理"></a>Block管理<code>Objective-C</code>对象实例的原理</h2><hr>
<p><code>Block</code>的实现结构体见如下图所示，<code>Block</code>对于捕获的<code>Objective-C</code>对象实例，会在<code>Block</code>实现的结构体中创建一个变量指向<code>Objective-C</code>对象实例，当<code>Block</code>将要释放时，会调用<code>dispose_helper</code>函数，该函数会调用所有需要进行内存管理的所捕获的对象，如<code>Block</code>、<code>__block</code>变量、<code>__attribute__((NSObject))</code>变量或有<code>constructor/destructor</code>的<code>C++</code> <code>const</code>对象。</p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/master/images/blog/Block.png"></p>
<h2 id="获取Block-retain的Objective-C对象实例"><a href="#获取Block-retain的Objective-C对象实例" class="headerlink" title="获取Block retain的Objective-C对象实例"></a>获取Block retain的Objective-C对象实例</h2><hr>
<p>所以，怎么能够拿到<code>retain</code>的<code>Objective-C</code>对象实例呢，方法为创建<code>fake</code>对象，来模拟捕获的<code>Objective-C</code>对象实例，然后我们程序来调用<code>Block</code>的<code>dispose_helper</code>方法（<code>dispose_helper</code>方法接收一个参数，值为<code>Block</code>的指针），该方法会调用对象实例的<code>release</code>方法，我们只需要在<code>fake</code>对象中实现<code>release</code>方法，如果<code>release</code>方法被调用，所以该<code>fake</code>对象对应的真实变量为<code>Objective-C</code>对象实例。</p>
<p>那么需要创建多少个<code>fake</code>对象呢，首先，<code>Objective-C</code>对象实例在<code>Block</code>的<code>struct</code>中的位置是指针对齐的，所以我们可以获取<code>Block</code>结构体的大小，除以指针的大小取上即为需要创建的<code>fake</code>对象的数量,<code>Block</code>结构体的<code>size</code>可以通过<code>block-&gt;descriptor-&gt;size</code>来获取。</p>
<p>得到需要创建<code>fake</code>对象的数量<code>count</code>后，创建一个数组，再创建<code>count</code>个<code>fake</code>对象，将数组指针传入<code>dispose_helper</code>即可。对于调用了<code>release</code>方法的对象，记录其索引值，通过访问<code>block[index]</code>即可拿到真正的<code>Objective-C</code>对象实例。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><hr>
<p>如上所说的捕获的<code>Objective-C</code>对象实例，不包括使用<code>__block</code>创建的实例，因为使用<code>__block</code>创建的变量，会加一层间接层，并不会在<code>Block</code>结构体中创建指向实例对象的变量，而是指向另一个间接层结构体。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://clang.llvm.org/docs/Block-ABI-Apple.html">https://clang.llvm.org/docs/Block-ABI-Apple.html</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/mikeash/Circle/blob/master/Circle/CircleIVarLayout.m">https://github.com/mikeash/Circle/blob/master/Circle/CircleIVarLayout.m</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/06/13/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BSwapped-Memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/06/13/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B9%8BSwapped-Memory/" class="post-title-link" itemprop="url">iOS内存管理之Swapped Memory</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-06-13 17:00:10 / 修改时间：18:05:35" itemprop="dateCreated datePublished" datetime="2018-06-13T17:00:10+08:00">2018-06-13</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">iOS开发-其它</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Swap-Space"><a href="#Swap-Space" class="headerlink" title="Swap Space"></a>Swap Space</h2><hr>
<p><code>Linux</code>、<code>Macos</code>等系统有一个<code>Swap space</code>的概念，当物理内存紧张时，系统会将<code>inactive</code>的<code>pages</code>放到<code>Swap Space</code>，<code>Swap Space</code>为磁盘上的某个区域，一般是文件形式，这样能节省出来一部分的物理内存，不过，当我们需要访问已经放到磁盘中的内存时，由于已经不在物理内存中，会引发缺页中断，需要再次从磁盘中重新读取，所以会比直接从内存获取要慢。</p>
<p>不过<code>iOS</code>系统并没有<code>Swap Space</code>，原因可能有二，其一是<code>iPhone</code>的<code>Flash</code>闪存空间受限；其二是<code>CPU</code>受限，因为手机的<code>CPU</code>相比电脑还是有一定差距。</p>
<h2 id="Swapped-Size"><a href="#Swapped-Size" class="headerlink" title="Swapped Size"></a>Swapped Size</h2><hr>
<p><code>iOS</code>中，内存分为两种，一种为<code>Clean memory</code>，另一种为<code>Dirty memory</code>；<br><code>Clean memory</code>的<code>page</code>可以换出，既磁盘中有其对应内容，系统可以在内存紧张时将<code>Clean memory</code>的<code>page</code>换出，当再次访问时，可以重新从磁盘中读取，我们使用的图片、<code>mapped files</code>、<code>Framework</code>的数据段常量以及代码段等，这些都是<code>Clean memory</code>。<br><code>Dirty memory</code>是无法换出的，我们所有的堆上的分配等都是属于<code>Dirty memory</code>,所以我们一定要尽可能的减少<code>Dirty memory</code>的使用。</p>
<p>从<code>iOS7</code>开始，<code>iOS</code>引入了<code>Compression</code>的概念，如下图为<code>Instruments</code>的<code>Allocations template</code>，我们可以从标红的地方看到，有一个<code>Swapped Size</code>的指标，从<a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf">WWDC 2018 416</a>得知，该指标的含义为<code>compression size</code>，即系统可以把最近最少使用的<code>Dirty memory</code>进行压缩，这样可以腾出一些<code>pages</code>供使用，当再次需要访问内容时，系统将其解压，这时，原来内容占多少<code>pages</code>，解压后同样会是相同数量的<code>pages</code>。</p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/b14b5edf5c614b290b9ad0d5cdcbb81c1a6583d7/images/blog/ios-swapped-size.png"></p>
<p><img src="https://raw.githubusercontent.com/zhongwuzw/zhongwuzw.github.io.resource/b14b5edf5c614b290b9ad0d5cdcbb81c1a6583d7/images/blog/ios-memory-compression.png"></p>
<p>上图为<code>JetsamEvent</code>的log，展示了<code>compression size</code>等指标，<code>jetsam_thread</code>线程运行在阻塞的循环中，当唤起时，根据内存列表来<code>kill</code>掉处于<code>top</code>的进程，当内存足够时，再次进入休眠。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf">https://devstreaming-cdn.apple.com/videos/wwdc/2018/416n2fmzz0fz88f/416/416_ios_memory_deep_dive.pdf</a></li>
<li><a target="_blank" rel="noopener" href="http://newosxbook.com/articles/MemoryPressure.html">http://newosxbook.com/articles/MemoryPressure.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/05/22/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8Bmain-queue-main-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/22/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8Bmain-queue-main-thread/" class="post-title-link" itemprop="url">iOS知识小集之main-queue!=main-thread</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-05-22 20:55:25 / 修改时间：21:47:38" itemprop="dateCreated datePublished" datetime="2018-05-22T20:55:25+08:00">2018-05-22</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">iOS开发-其它</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="GCD-main-queue和main-thread的关系"><a href="#GCD-main-queue和main-thread的关系" class="headerlink" title="GCD main queue和main thread的关系"></a>GCD <code>main queue</code>和<code>main thread</code>的关系</h2><hr>
<p><code>dispatch_get_main_queue()</code>返回<code>main queue</code>，该队列会被绑定到<code>main thread</code>，所以我们如果我们将<code>block</code>提交到<code>main queue</code>，那么该<code>block</code>将会在主线程中执行。</p>
<h2 id="dispatch-sync-queue-block-向-main-queue提交block"><a href="#dispatch-sync-queue-block-向-main-queue提交block" class="headerlink" title="dispatch_sync(queue, block)向 main queue提交block"></a><code>dispatch_sync(queue, block)</code>向 <code>main queue</code>提交<code>block</code></h2><hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/// Current thread is main thread</span><br><span class="line">dispatch_sync(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, 0), ^&#123;</span><br><span class="line">        NSLog(@&quot;Is main thread? %d&quot;, [NSThread isMainThread]);</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">/// output:</span><br><span class="line">/// &quot;Is main thread? 1&quot;</span><br></pre></td></tr></table></figure>

<p>大家有没有注意到，<code>Log</code>输出表明执行<code>Block</code>时的线程为主线程，根据我们以往的经验，<code>dispatch_get_global_queue</code>获取到的队列，队列中的<code>Block</code>应该是在<code>Secondly thread</code>中执行，为什么这里会是在主线程中呢。</p>
<p>答案就是在<code>dispatch_sync</code>语句，<code>libdispatch</code>在<a target="_blank" rel="noopener" href="https://github.com/apple/swift-corelibs-libdispatch/commit/e64e4b962e1f356d7561e7a6103b424f335d85f6">commit</a>中进行了优化，只要目标<code>queue</code>不是<code>main queue</code>，那么提交的<code>Block</code>就会直接在原线程中执行，这就能解释为什么上面的<code>demo</code>程序中输出的<code>Log</code>显示是主线程。</p>
<p>那么，这种会不会有潜在的问题呢？</p>
<h2 id="isMainThread带来的潜在问题"><a href="#isMainThread带来的潜在问题" class="headerlink" title="isMainThread带来的潜在问题"></a><code>isMainThread</code>带来的潜在问题</h2><hr>
<p>首先，我们看一个<a target="_blank" rel="noopener" href="http://www.openradar.me/24025596">Radar</a>，大概意思是，即使<code>MapKit</code>框架的<code>addOverlay</code>方法在主线程执行，但是由于其不是在<code>main queue</code>中执行的，会导致<code>Crash</code>，这是因为<code>MapKit</code>内部在<code>main queue</code>中使用<code>dispatch_queue_set_specific</code>设置了数据，当你在其它队列中执行时，会由于没有该数据从而导致<code>Crash</code>。</p>
<h2 id="避免使用isMainThread"><a href="#避免使用isMainThread" class="headerlink" title="避免使用isMainThread"></a>避免使用<code>isMainThread</code></h2><hr>
<p>所以，我们需要避免使用<code>isMainThread</code>，而是判断是不是<code>main queue</code>，我们可以使用两种方法来判断：</p>
<ol>
<li>使用<code>dispatch_queue_set_specific</code>在<code>main queue</code>上设置<code>flag</code>，然后做判断，有该<code>flag</code>即为<code>main queue</code>.</li>
<li>判断<code>dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL) == dispatch_queue_get_label(dispatch_get_main_queue())</code>，<code>main queue</code>设置了<code>label</code>，可以通过其来判断。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><hr>
<ol>
<li><code>main queue</code>中的<code>Block</code>一定在主线程中执行。</li>
<li>主线程可以对应多个<code>queue</code>，既可以有任意的队列，其<code>Block</code>可以在主线程中执行。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083">https://github.com/ReactiveCocoa/ReactiveCocoa/issues/2635#issuecomment-170215083</a></li>
<li><a target="_blank" rel="noopener" href="http://www.openradar.me/24025596">http://www.openradar.me/24025596</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/05/05/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8BSwift%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BAObjective-C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/05/05/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8BSwift%E9%97%AD%E5%8C%85%E4%BD%9C%E4%B8%BAObjective-C%E6%96%B9%E6%B3%95%E5%8F%82%E6%95%B0/" class="post-title-link" itemprop="url">iOS知识小集之Swift闭包作为Objective-C方法参数</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-05-05 23:30:30" itemprop="dateCreated datePublished" datetime="2018-05-05T23:30:30+08:00">2018-05-05</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-05-22 20:25:48" itemprop="dateModified" datetime="2018-05-22T20:25:48+08:00">2018-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">iOS开发-其它</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Swift闭包作为Objective-C方法参数"><a href="#Swift闭包作为Objective-C方法参数" class="headerlink" title="Swift闭包作为Objective-C方法参数"></a>Swift闭包作为Objective-C方法参数</h2><hr>
<p>在<code>Swift</code>开发时，有时我们需要调用带有<code>Block</code>参数的<code>Objective-C</code>方法，比如，我们通过<code>perform(_:with:afterDelay:inModes:)</code>来在特定的<code>Runloop</code>模式下运行某<code>selector</code>，如下所示，<code>doAnimation</code>方法接收一个<code>Optional</code>的<code>Block</code>，注意，该方法标注了<code>@objc</code>，所以是<code>Objective-C</code>方法，<code>animationBlock</code>参数为<code>Objective-C</code>的<code>Block</code>，那么我们怎么将<code>Swift</code>的<code>Closure</code>转化为<code>Block</code>呢，方法就是使用<code>@convention(block)</code>来声明兼容<code>Objective-C</code> <code>Block</code>的<code>Closure</code>，如下<code>[1]</code>所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class LocationMessageCell: UICollectionViewCell &#123;</span><br><span class="line">    func callSEL() &#123;</span><br><span class="line">        let block: @convention(block) (UIImageView) -&gt; Void = &#123; _ in    // [1]</span><br><span class="line">        ....</span><br><span class="line">        &#125;</span><br><span class="line">        self.perform(#selector(LocationMessageCell.doAnimation(with:)), with: block, afterDelay: 0, inModes: [.defaultRunLoopMode])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @objc private func doAnimation(with animationBlock: ((UIImageView) -&gt; Void)!) &#123;</span><br><span class="line">        ....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了显式的用<code>@convention(block)</code>来声明，我们也可以直接使用闭包，如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">UIView.animate(withDuration: 0.1, animations: &#123;</span><br><span class="line">    ...                </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>注意，之所以我没有在之前的例子进行修改，是因为<code>func perform(_ aSelector: Selector, with anArgument: Any?, afterDelay delay: TimeInterval, inModes modes: [RunLoopMode])</code>的<code>anArgument</code>参数类型为<code>Any?</code>，编译器没有进行自动转换，这种情况只能显式的声明<code>@convention(block)</code>。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html">https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithObjective-CAPIs.html</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/04/21/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88objc-msgSend-%E6%98%AF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%9A%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/04/21/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88objc-msgSend-%E6%98%AF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%9A%84/" class="post-title-link" itemprop="url">iOS知识小集之为什么objc_msgSend()是用汇编实现的</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2018-04-21 23:07:30" itemprop="dateCreated datePublished" datetime="2018-04-21T23:07:30+08:00">2018-04-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2018-05-22 20:26:18" itemprop="dateModified" datetime="2018-05-22T20:26:18+08:00">2018-05-22</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E5%85%B6%E5%AE%83/" itemprop="url" rel="index"><span itemprop="name">iOS开发-其它</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h2><hr>
<p>在使用<code>Objective-C</code>调用方法时，我们将其称之为消息发送，这与我们用的<code>C</code>、<code>C++</code>等调用函数的说法不一样，原因就是<code>Objective-C</code>调用方法时，并不是简单的会在编译时得到函数指针，调用时直接使用该函数指针调用就行（<code>C++</code>有虚函数，包含一个<code>v-table</code>，可以实现简单的多态），而是会在调用的时候，运行时的去查找函数实现，比如，当我们发送<code>[objc foo]</code>时，编译器会将其转化为<code>objc_msgSend(objc, @selector(foo))</code>(注意，不一定都是转化为<code>objc_msgSend</code>，根据发送对象和返回类型，可转化为<code>objc_msgSendSuper</code>,<code>objc_msgSendSuper_stret</code>等)，<code>objc_msgSend</code>方法负责查找函数实现并调用返回结果，我们知道，<code>Objc Runtime</code>是<a target="_blank" rel="noopener" href="https://github.com/zhongwuzw/objc4-cn">开源</a>的，所以我们可以看一下源代码<code>objc_msgSend</code>的实现逻辑。</p>
<h2 id="objc-msgSend-使用汇编实现"><a href="#objc-msgSend-使用汇编实现" class="headerlink" title="objc_msgSend()使用汇编实现"></a>objc_msgSend()使用汇编实现</h2><hr>
<p>源码可参见<a target="_blank" rel="noopener" href="https://github.com/zhongwuzw/objc4-cn/blob/087a6fd60e3cad2934163b26aa484640d6ff9467/runtime/Messengers.subproj/objc-msg-arm64.s#L286">objc_msgSend源码</a>，我们发现，竟然不是用<code>C</code>实现的，而是使用的汇编语言，总结来说，原因有二：</p>
<ol>
<li>我们无法定义一个<code>C</code>函数，可以有可变的参数(可变参数是可以实现的，参考<code>printf</code>函数)并且可以调用任意的<code>C</code>函数指针，因为函数指针类型是在是无穷无尽的，根本就无法预先全部定义出来。
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2018/04/21/iOS%E7%9F%A5%E8%AF%86%E5%B0%8F%E9%9B%86%E4%B9%8B%E4%B8%BA%E4%BB%80%E4%B9%88objc-msgSend-%E6%98%AF%E7%94%A8%E6%B1%87%E7%BC%96%E5%AE%9E%E7%8E%B0%E7%9A%84/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2018/01/30/Goroutines-vs-%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2018/01/30/Goroutines-vs-%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">Goroutines vs 多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2018-01-30 10:56:47 / 修改时间：12:45:44" itemprop="dateCreated datePublished" datetime="2018-01-30T10:56:47+08:00">2018-01-30</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Go/" itemprop="url" rel="index"><span itemprop="name">Go</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<p><a target="_blank" rel="noopener" href="https://golang.google.cn/">Golang</a>是由<code>Google</code>开发，天生支持并发的语言。<code>Go</code>有一个<code>goroutine</code>的机制，当我们在调用函数前加上<code>go</code>关键字，那么就会创建一个<code>goroutine</code>来异步执行该函数，如：<code>go foo()</code>，以此来实现并发的功能。本文，我们将讨论一下<code>goroutine</code>和线程的区别。</p>
<h2 id="大小可调整的栈"><a href="#大小可调整的栈" class="headerlink" title="大小可调整的栈"></a>大小可调整的栈</h2><hr>
<p>线程可以在启动前设置栈的大小，启动后，线程的栈大小就固定了，所以带来的弊端就是浪费内存空间，因为很多时候并不需要这么多内存。<br>相比于线程，<code>goroutine</code>的栈空间是可调整的，<code>goroutine</code>创建时，通常只会分配<code>2KB</code>大小的栈，随着<code>goroutine</code>的运行，比如不断的递归，创建变量等，相应的栈空间也会增大，反之也会按需减小，一个<code>goroutine</code>最大可分配栈空间通常为<code>1GB</code>。</p>
<h2 id="goroutine-的调度"><a href="#goroutine-的调度" class="headerlink" title="goroutine 的调度"></a><code>goroutine</code> 的调度</h2><hr>
<p>线程由系统内核进行调度，系统为了实现并发，会不断的切换线程的执行，由此会带来线程的上下文切换。<br>而<code>Go</code>的运行时有一套自己的调度系统，使用<code>m:n</code>策略，既复用<code>m</code>个<code>goroutine</code>到<code>n</code>个线程，<code>Go</code>的调度器类似于内核调度器，区别是它仅管理单个<code>Go</code>程序创建的<code>goroutine</code>。<br>相比于线程，<code>Go</code>的调度器并不会周期性的被硬件定时器调用，而是<code>Go</code>自己来处理，比如，当一个<code>goroutine</code>调用<code>time.Sleep</code>或阻塞与通道、互斥操作时，调度器会将<code>goroutine</code>休眠，然后运行另外的<code>goroutine</code>，这些并不需要内核的上下文切换，所以重新调度一个<code>goroutine</code>的开销会小于重新调度线程的开销。</p>
<h2 id="GOMAXPROCS"><a href="#GOMAXPROCS" class="headerlink" title="GOMAXPROCS"></a><code>GOMAXPROCS</code></h2><hr>
<p><code>Go</code>的调度器使用一个名为<code>GOMAXPROCS</code>的参数来确定真正的线程数，其默认值为机器的<code>CPU</code>的数量，如一台机器有8个<code>CPU</code>,那么调度器会同时创建8个线程（<code>GOMAXPROCS</code>就是如上所说<code>m:n</code>中的<code>n</code>)。休眠或阻塞中<code>goroutine</code>不需要线程，但是对于阻塞在<code>I/O</code>或系统调用、正在调用非<code>Go</code>函数的<code>goroutine</code>来说，需要一个系统线程，不过不占用<code>GOMAXPROCS</code>。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://golang.google.cn/">https://golang.google.cn</a></li>
<li><a target="_blank" rel="noopener" href="http://www.gopl.io/">http://www.gopl.io</a></li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2017/11/16/Objective-C-%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/11/16/Objective-C-%E4%B9%8B%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" class="post-title-link" itemprop="url">Objective-C++之内存管理</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>
      

      <time title="创建时间：2017-11-16 10:28:46 / 修改时间：11:37:41" itemprop="dateCreated datePublished" datetime="2017-11-16T10:28:46+08:00">2017-11-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">iOS开发-语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Objective-C-内存管理"><a href="#Objective-C-内存管理" class="headerlink" title="Objective-C++内存管理"></a>Objective-C++内存管理</h2><hr>
<p>在项目开发时，有时会使用<code>C++</code>来进行混合开发，因为<code>C++</code>有很好的跨平台及性能优势。我们可以将<code>C++</code>对象作为<code>Objective-C</code>的属性或者反过来<code>Objective-C</code>作为<code>C++</code>对象的成员，当我们需要在App中使用C++库时，会很有用。</p>
<p>当我们的文件同时使用了<code>Objective-C</code>和<code>C++</code>时，需要告知编译器来进行处理，方法为将该文件的后缀从<code>.m</code>改为<code>.mm</code>。</p>
<p>如下示例展示了<code>Objective-C</code>和<code>C++</code>互相作为成员变量来关联：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">// Forward declare so that everything works below</span><br><span class="line">@class ObjcClass;</span><br><span class="line">class CppClass;</span><br><span class="line"></span><br><span class="line">// C++ class with an Objective-C member variable</span><br><span class="line">class CppClass &#123;</span><br><span class="line">  public:</span><br><span class="line">    ObjcClass *objcClass;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// Objective-C class with a C++ object as a property</span><br><span class="line">@interface ObjcClass : NSObject</span><br><span class="line">@property (nonatomic, assign) std::shared_ptr&lt;CppClass&gt; cppClass;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation ObjcClass</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">// Using the two classes above</span><br><span class="line">std::shared_ptr&lt;CppClass&gt; cppClass(new CppClass());</span><br><span class="line">ObjcClass *objcClass = [[ObjcClass alloc] init];</span><br><span class="line"></span><br><span class="line">cppClass-&gt;objcClass = objcClass;</span><br><span class="line">objcClass.cppClass = cppClass;</span><br></pre></td></tr></table></figure>

<p>如上，我们注意到，属性声明成了<code>assign</code>，而不是我们通常使用的<code>strong</code>、<code>weak</code>，原因就是对于非<code>Objective-C</code>类型对象来说是没有意义的，编译器无法<code>retain</code>或<code>release</code>一个<code>C++</code>对象，因为它不是一个<code>Objective-C</code>对象类型。</p>
<p>尽管声明属性为<code>assign</code>，但是内存管理依然能正确处理；不过这里要注意的是，如果我们使用原始指针来保存，这时候就需要自己进行内存管理了。</p>
<p><code>Objective-C</code>对象实例总是在堆上分配，但是<code>C++</code>实例可以在栈或堆上。所以我们把分配在栈上的<code>C++</code>实例赋值给<code>Objective-C</code>的成员变量时，就有点奇怪，不过不用担心，它其实会放到堆上，因为整个<code>Objective-C</code>对象都是在堆上的。编译器实现这个转化的方式为：在<code>alloc</code>和<code>dealloc</code>方法中构建和析构<code>C++</code>对象，分别调用<code>object_cxxConstruct</code>、<code>object_cxxDestruct</code>方法，来处理<code>C++</code>对象。</p>
<p>所以，对于所有基于栈的<code>C++</code>对象，不需要担心内存的问题，编译器自动接管。但是再强调一下，基于堆的<code>C++</code>对象，需要手动管理内存，如在<code>dealloc</code>中<code>delete``C++</code>对象。</p>
<p><code>Game Over!!!</code></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://zhongwuzw.github.io/2017/09/21/%E8%81%8A%E8%81%8Adealloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="钟武">
      <meta itemprop="description" content="Keep thinking, keep coding!!!">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="钟武的技术博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2017/09/21/%E8%81%8A%E8%81%8Adealloc/" class="post-title-link" itemprop="url">聊聊dealloc</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2017-09-21 17:52:34" itemprop="dateCreated datePublished" datetime="2017-09-21T17:52:34+08:00">2017-09-21</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2017-09-25 11:25:49" itemprop="dateModified" datetime="2017-09-25T11:25:49+08:00">2017-09-25</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/iOS%E5%BC%80%E5%8F%91-%E8%AF%AD%E8%A8%80/" itemprop="url" rel="index"><span itemprop="name">iOS开发-语言</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><hr>
<blockquote>
<p>所有代码注释可在<a target="_blank" rel="noopener" href="https://github.com/zhongwuzw/ObjC-Runtime">Objc-Runtime</a>中查看</p>
</blockquote>
<p>在<code>iOS</code>开发中，我们经常会通过<code>dealloc</code>来判断对象实例是否被释放，依据是当对象实例的引用计数变为0时，运行时会调用对象实例的<code>dealloc</code>方法，我们可以利用该方法做一些扫尾的工作。</p>
<h2 id="dealloc调用时机"><a href="#dealloc调用时机" class="headerlink" title="dealloc调用时机"></a>dealloc调用时机</h2><hr>
<p><code>Objective-C</code>的引用计数管理使用两种方式相结合，<code>sidetable</code>和<code>isa</code>指针（指针并不是对象的真正内存地址，而是某些位用来进行了一些标志位的存放）；接下来，我将以<code>sidetable</code>进行<code>release</code>来讨论<code>dealloc</code>的调用，直接上代码，如下<code>sidetable_release</code>（下文所有都会用<code>sidetable_release</code>来讨论）函数会在给对象发送<code>release</code>消息的时候调用，<code>sidetable_release</code>方法首先获取对象的引用计数，对引用计数相关标志位做操作，若对象实例可以被释放，将通过<code>objc_msgSend</code>发送<code>SEL_dealloc</code>消息，既调用对象的<code>dealloc</code>方法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">uintptr_t</span><br><span class="line">objc_object::sidetable_release(bool performDealloc)</span><br><span class="line">&#123;</span><br><span class="line">#if SUPPORT_NONPOINTER_ISA</span><br><span class="line">    assert(!isa.nonpointer);</span><br><span class="line">#endif</span><br><span class="line">    SideTable&amp; table = SideTables()[this];</span><br><span class="line"></span><br><span class="line">    bool do_dealloc = false;</span><br><span class="line"></span><br><span class="line">    table.lock();</span><br><span class="line">    RefcountMap::iterator it = table.refcnts.find(this);</span><br><span class="line">    if (it == table.refcnts.end()) &#123;</span><br><span class="line">        do_dealloc = true;</span><br><span class="line">        table.refcnts[this] = SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; else if (it-&gt;second &lt; SIDE_TABLE_DEALLOCATING) &#123;</span><br><span class="line">        // SIDE_TABLE_WEAKLY_REFERENCED may be set. Don&#x27;t change it.</span><br><span class="line">        do_dealloc = true;</span><br><span class="line">        it-&gt;second |= SIDE_TABLE_DEALLOCATING;</span><br><span class="line">    &#125; else if (! (it-&gt;second &amp; SIDE_TABLE_RC_PINNED)) &#123;</span><br><span class="line">        it-&gt;second -= SIDE_TABLE_RC_ONE;</span><br><span class="line">    &#125;</span><br><span class="line">    table.unlock();</span><br><span class="line">    // 进行释放操作，调用dealloc</span><br><span class="line">    if (do_dealloc  &amp;&amp;  performDealloc) &#123;</span><br><span class="line">        ((void(*)(objc_object *, SEL))objc_msgSend)(this, SEL_dealloc);</span><br><span class="line">    &#125;</span><br><span class="line">    return do_dealloc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/2017/09/21/%E8%81%8A%E8%81%8Adealloc/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2016 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">钟武</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  





  





</body>
</html>
